<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ncem.estimators.base_estimator &mdash; ncem 0.1.4 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/custom_cookietemple.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> ncem
          </a>
              <div class="version">
                0.1.4
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html">ncem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ecosystem.html">Ecosystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributor Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../code_of_conduct.html">Contributor Covenant Code of Conduct</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ncem</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>ncem.estimators.base_estimator</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ncem.estimators.base_estimator</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>

<span class="kn">from</span> <span class="nn">ncem.utils.losses</span> <span class="kn">import</span> <span class="n">GaussianLoss</span><span class="p">,</span> <span class="n">KLLoss</span><span class="p">,</span> <span class="n">NegBinLoss</span>
<span class="kn">from</span> <span class="nn">ncem.utils.metrics</span> <span class="kn">import</span> <span class="p">(</span><span class="n">custom_kl</span><span class="p">,</span> <span class="n">custom_mae</span><span class="p">,</span> <span class="n">custom_mean_sd</span><span class="p">,</span>
                                <span class="n">custom_mse</span><span class="p">,</span> <span class="n">custom_mse_scaled</span><span class="p">,</span>
                                <span class="n">gaussian_reconstruction_loss</span><span class="p">,</span> <span class="n">logp1_custom_mse</span><span class="p">,</span>
                                <span class="n">logp1_r_squared</span><span class="p">,</span> <span class="n">logp1_r_squared_linreg</span><span class="p">,</span>
                                <span class="n">nb_reconstruction_loss</span><span class="p">,</span> <span class="n">r_squared</span><span class="p">,</span>
                                <span class="n">r_squared_linreg</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">transfer_layers</span><span class="p">(</span><span class="n">model1</span><span class="p">,</span> <span class="n">model2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transfer layer weights from model 1 to model 2.</span>

<span class="sd">    :param model1: Input model.</span>
<span class="sd">    :param model2: Output model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">layer_names_model1</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">model1</span><span class="o">.</span><span class="n">layers</span><span class="p">]</span>
    <span class="n">layer_names_model2</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">model2</span><span class="o">.</span><span class="n">layers</span><span class="p">]</span>
    <span class="n">layers_updated</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">layer_not_updated</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">layer_names_model2</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">layer_names_model1</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">model1</span><span class="o">.</span><span class="n">get_layer</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">get_weights</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">layer_names_model2</span><span class="p">:</span>
            <span class="c1"># Only update layers with parameters:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">model2</span><span class="o">.</span><span class="n">get_layer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="n">layers_updated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">layer_not_updated</span> <span class="o">=</span> <span class="n">layer_not_updated</span><span class="o">.</span><span class="n">difference</span><span class="p">({</span><span class="n">x</span><span class="p">})</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;updated layers: </span><span class="si">{</span><span class="n">layers_updated</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;did not update layers: </span><span class="si">{</span><span class="n">layer_not_updated</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="Estimator"><a class="viewcode-back" href="../../../api/ncem.estimators.Estimator.html#ncem.estimators.Estimator">[docs]</a><span class="k">class</span> <span class="nc">Estimator</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Estimator class for models.</span>

<span class="sd">    Contains all necessary methods for data loading, model initialization, training, evaluation and prediction.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">img_to_patient_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
    <span class="n">complete_img_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>

    <span class="n">a</span><span class="p">:</span> <span class="nb">dict</span>  <span class="c1"># dict of adjacency matrices of shape (max_nodes, max_nodes)</span>
    <span class="n">h_0</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>  <span class="c1"># dict of adjacency matrices of shape (max_nodes, n_features_0)</span>
    <span class="n">h_1</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>  <span class="c1"># dict of adjacency matrices of shape (max_nodes, n_features_1)</span>
    <span class="n">size_factors</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
    <span class="n">graph_covar</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
    <span class="n">node_covar</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
    <span class="n">domains</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>

    <span class="n">covar_selection</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span>

    <span class="n">node_types</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
    <span class="n">node_type_names</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
    <span class="n">graph_covar_names</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span>
    <span class="n">node_feature_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>

    <span class="n">n_features_type</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">n_features_standard</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">n_features_0</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">n_features_1</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">n_graph_covariates</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">n_node_covariates</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">n_domains</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">max_nodes</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">n_eval_nodes_per_graph</span><span class="p">:</span> <span class="nb">int</span>

    <span class="n">vi_model</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">log_transform</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">model_type</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">adj_type</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">cond_type</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">cond_depth</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">output_layer</span><span class="p">:</span> <span class="nb">str</span>

    <span class="n">img_keys_test</span> <span class="o">=</span> <span class="nb">list</span>
    <span class="n">img_keys_eval</span> <span class="o">=</span> <span class="nb">list</span>
    <span class="n">img_keys_train</span> <span class="o">=</span> <span class="nb">list</span>

    <span class="n">nodes_idx_test</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span>
    <span class="n">nodes_idx_eval</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span>
    <span class="n">nodes_idx_train</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span>

    <span class="n">steps_per_epoch</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">validation_steps</span><span class="p">:</span> <span class="nb">int</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize Estimator class.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loss</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_beta</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pre_warm_up</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_hyperparam</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pretrain_history</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">train_dataset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eval_dataset</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_load_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data_origin</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">data_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_rings</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">label_selection</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_top_genes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a DataLoader object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_origin : str</span>
<span class="sd">            Data origin.</span>
<span class="sd">        data_path : str</span>
<span class="sd">            Data path.</span>
<span class="sd">        radius : int</span>
<span class="sd">            Radius.</span>
<span class="sd">        label_selection : list, optional</span>
<span class="sd">            Label selection.</span>
<span class="sd">        n_top_genes: int, optional</span>
<span class="sd">            N top genes for highly variable gene selection.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `data_origin` not recognized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coord_type</span> <span class="o">=</span> <span class="s1">&#39;generic&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targeted_assay</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">data_origin</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;zhang&quot;</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">ncem.data</span> <span class="kn">import</span> <span class="n">DataLoaderZhang</span> <span class="k">as</span> <span class="n">DataLoader</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">undefined_node_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;other&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">data_origin</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;jarosch&quot;</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">ncem.data</span> <span class="kn">import</span> <span class="n">DataLoaderJarosch</span> <span class="k">as</span> <span class="n">DataLoader</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">undefined_node_types</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">data_origin</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;hartmann&quot;</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">ncem.data</span> <span class="kn">import</span> <span class="n">DataLoaderHartmann</span> <span class="k">as</span> <span class="n">DataLoader</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">undefined_node_types</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">data_origin</span> <span class="o">==</span> <span class="s2">&quot;pascualreguant&quot;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">ncem.data</span> <span class="kn">import</span> <span class="n">DataLoaderPascualReguant</span> <span class="k">as</span> <span class="n">DataLoader</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">undefined_node_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;other&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">data_origin</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;schuerch&quot;</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">ncem.data</span> <span class="kn">import</span> <span class="n">DataLoaderSchuerch</span> <span class="k">as</span> <span class="n">DataLoader</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">undefined_node_types</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;dirt&quot;</span><span class="p">,</span>
                <span class="s2">&quot;undefined&quot;</span><span class="p">,</span>
                <span class="s2">&quot;tumor cells / immune cells&quot;</span><span class="p">,</span>
                <span class="s2">&quot;immune cells / vasculature&quot;</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="k">elif</span> <span class="n">data_origin</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;lohoff&#39;</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">ncem.data</span> <span class="kn">import</span> <span class="n">DataLoaderLohoff</span> <span class="k">as</span> <span class="n">DataLoader</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">undefined_node_types</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Low quality&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">data_origin</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;luwt&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">data_origin</span> <span class="o">==</span> <span class="s2">&quot;luwt_imputation&quot;</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">ncem.data</span> <span class="kn">import</span> <span class="n">DataLoaderLuWTimputed</span> <span class="k">as</span> <span class="n">DataLoader</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">ncem.data</span> <span class="kn">import</span> <span class="n">DataLoaderLuWT</span> <span class="k">as</span> <span class="n">DataLoader</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">undefined_node_types</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Unknown&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">data_origin</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;lutet2&quot;</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">ncem.data</span> <span class="kn">import</span> <span class="n">DataLoaderLuTET2</span> <span class="k">as</span> <span class="n">DataLoader</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">undefined_node_types</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Unknown&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">data_origin</span> <span class="o">==</span> <span class="s2">&quot;10xvisium&quot;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">ncem.data</span> <span class="kn">import</span> <span class="n">DataLoader10xVisiumMouseBrain</span> <span class="k">as</span> <span class="n">DataLoader</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">undefined_node_types</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">n_rings</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">coord_type</span> <span class="o">=</span> <span class="s1">&#39;grid&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_rings</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">coord_type</span> <span class="o">=</span> <span class="s1">&#39;generic&#39;</span>
                <span class="n">radius</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">data_origin</span> <span class="o">==</span> <span class="s2">&quot;10xvisium_lymphnode&quot;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">ncem.data</span> <span class="kn">import</span> <span class="n">DataLoader10xLymphnode</span> <span class="k">as</span> <span class="n">DataLoader</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">undefined_node_types</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">n_rings</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">coord_type</span> <span class="o">=</span> <span class="s1">&#39;grid&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_rings</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">coord_type</span> <span class="o">=</span> <span class="s1">&#39;generic&#39;</span>
                <span class="n">radius</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">elif</span> <span class="n">data_origin</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;destvi_lymphnode&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">targeted_assay</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="kn">from</span> <span class="nn">ncem.data</span> <span class="kn">import</span> <span class="n">DataLoaderDestViLymphnode</span> <span class="k">as</span> <span class="n">DataLoader</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">undefined_node_types</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">data_origin</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;destvi_mousebrain&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">targeted_assay</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="kn">from</span> <span class="nn">ncem.data</span> <span class="kn">import</span> <span class="n">DataLoaderDestViMousebrain</span> <span class="k">as</span> <span class="n">DataLoader</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">undefined_node_types</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">elif</span> <span class="n">data_origin</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;cell2location_lymphnode&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">targeted_assay</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="kn">from</span> <span class="nn">ncem.data</span> <span class="kn">import</span> <span class="n">DataLoaderCell2locationLymphnode</span> <span class="k">as</span> <span class="n">DataLoader</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">undefined_node_types</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">elif</span> <span class="n">data_origin</span> <span class="o">==</span> <span class="s2">&quot;salasiss&quot;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">ncem.data</span> <span class="kn">import</span> <span class="n">DataLoaderSalasIss</span> <span class="k">as</span> <span class="n">DataLoader</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">undefined_node_types</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span>
            <span class="n">data_path</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span> <span class="n">coord_type</span><span class="o">=</span><span class="n">coord_type</span><span class="p">,</span> <span class="n">n_rings</span><span class="o">=</span><span class="n">n_rings</span><span class="p">,</span> <span class="n">label_selection</span><span class="o">=</span><span class="n">label_selection</span><span class="p">,</span>
            <span class="n">n_top_genes</span><span class="o">=</span><span class="n">n_top_genes</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Estimator.get_data"><a class="viewcode-back" href="../../../api/ncem.estimators.Estimator.get_data.html#ncem.estimators.Estimator.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data_origin</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">data_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">n_rings</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">graph_covar_selection</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">node_label_space_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;type&quot;</span><span class="p">,</span>
        <span class="n">node_feature_space_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;standard&quot;</span><span class="p">,</span>
        <span class="n">use_covar_node_position</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_covar_node_label</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_covar_graph_covar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">domain_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;image&quot;</span><span class="p">,</span>
        <span class="n">robustness</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">robustness_seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">n_top_genes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">segmentation_robustness</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">resimulate_nodes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">resimulate_nodes_w_depdency</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">resimulate_nodes_sparsity_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get data used in estimator classes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_origin : str</span>
<span class="sd">            Data origin.</span>
<span class="sd">        data_path : str</span>
<span class="sd">            Data path.</span>
<span class="sd">        radius : int, optional</span>
<span class="sd">            Radius.</span>
<span class="sd">        n_rings : int</span>
<span class="sd">            Number of rings of neighbors for grid data.</span>
<span class="sd">        graph_covar_selection : list, tuple, optional</span>
<span class="sd">            Selected graph covariates.</span>
<span class="sd">        node_label_space_id : str</span>
<span class="sd">            Node label space id.</span>
<span class="sd">        node_feature_space_id : str</span>
<span class="sd">            Node feature space id.</span>
<span class="sd">        use_covar_node_position : bool</span>
<span class="sd">            Whether to use node position as covariate.</span>
<span class="sd">        use_covar_node_label : bool</span>
<span class="sd">            Whether to use node label as covariate.</span>
<span class="sd">        use_covar_graph_covar : bool</span>
<span class="sd">            Whether to use graph covariates.</span>
<span class="sd">        domain_type : str</span>
<span class="sd">            Covariate that is used as domain.</span>
<span class="sd">        robustness : float, optional</span>
<span class="sd">            Optional fraction of images for robustness test.</span>
<span class="sd">        robustness_seed: int</span>
<span class="sd">            Seed for robustness analysis</span>
<span class="sd">        n_top_genes: int, optional</span>
<span class="sd">            N top genes for highly variable gene selection.</span>
<span class="sd">        segmentation_robustness: list, optional</span>
<span class="sd">            Parameters for segmentation robustness fit, float for fraction of nodes and float for signal overflow.</span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If sub-selected covar_selection could not be found, `node_label_space_id` or `node_feature_space_id`</span>
<span class="sd">            not recognized</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adj_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;set adj_type by init_estim() first&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">graph_covar_selection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">graph_covar_selection</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">labels_to_load</span> <span class="o">=</span> <span class="n">graph_covar_selection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_data</span><span class="p">(</span>
            <span class="n">data_origin</span><span class="o">=</span><span class="n">data_origin</span><span class="p">,</span>
            <span class="n">data_path</span><span class="o">=</span><span class="n">data_path</span><span class="p">,</span>
            <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span>
            <span class="n">n_rings</span><span class="o">=</span><span class="n">n_rings</span><span class="p">,</span>
            <span class="n">label_selection</span><span class="o">=</span><span class="n">labels_to_load</span><span class="p">,</span>
            <span class="n">n_top_genes</span><span class="o">=</span><span class="n">n_top_genes</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">robustness</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">robustness_seed</span><span class="p">)</span>
            <span class="n">n_images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="p">)</span> <span class="o">*</span> <span class="n">robustness</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">n_images</span><span class="p">)</span>
            <span class="n">image_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                <span class="n">a</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                <span class="n">size</span><span class="o">=</span><span class="n">n_images</span><span class="p">,</span>
                <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">image_keys</span><span class="p">}</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">celldata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s2">&quot;metadata&quot;</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">celldata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">celldata</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">celldata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;image_col&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">image_keys</span><span class="p">)]</span>

            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Attention: Running robustness model with a fraction </span><span class="si">%f</span><span class="s2"> images, so [</span><span class="si">%i</span><span class="s2">] images. </span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">This also adjusts celldata and img_celldata.&quot;</span>
                <span class="o">%</span> <span class="p">(</span>
                    <span class="n">robustness</span><span class="p">,</span>
                    <span class="n">n_images</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">segmentation_robustness</span><span class="p">:</span>
            <span class="n">node_fraction</span> <span class="o">=</span> <span class="n">segmentation_robustness</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">overflow_fraction</span> <span class="o">=</span> <span class="n">segmentation_robustness</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">total_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">celldata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">node_fraction</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">ad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">node_fraction</span><span class="p">)</span>
                <span class="n">random_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">obsp</span><span class="p">[</span><span class="s1">&#39;adjacency_matrix_connectivities&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
                <span class="n">err_ad</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">random_indices</span><span class="p">:</span>
                    <span class="n">adj</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">neigh_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">adj</span> <span class="o">==</span> <span class="mf">1.</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">err_ad</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">overflow_fraction</span> <span class="o">*</span> <span class="n">ad</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">neigh_idx</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">err_ad</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">neigh_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">overflow_fraction</span><span class="p">)</span> <span class="o">*</span> <span class="n">ad</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">neigh_idx</span><span class="p">,</span> <span class="p">:]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">err_ad</span>

            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Attention: Running segmentation robustness model on </span><span class="si">%f</span><span class="s2"> of all nodes, so [</span><span class="si">%i</span><span class="s2">] nodes. </span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Signal overflow is set to </span><span class="si">%f</span><span class="s2"> . This adjusts img_celldata, celldata remains unchanged.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span>
                    <span class="n">node_fraction</span><span class="p">,</span>
                    <span class="n">total_size</span><span class="p">,</span>
                    <span class="n">overflow_fraction</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simulation</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">resimulate_nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simulation</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">n_target_cell_types</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">resimulate_nodes_w_depdency</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="n">dependencies_per_type</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># Create map from real cell types to simulated ones (can be coarser):</span>
            <span class="n">found_all_types</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">futile_counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">node_type_map_idx</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">found_all_types</span><span class="p">:</span>
                <span class="n">node_type_map_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">n_target_cell_types</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">celldata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s2">&quot;node_type_names&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="p">])</span>
                <span class="n">futile_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">x</span> <span class="ow">in</span> <span class="n">node_type_map_idx</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_target_cell_types</span><span class="p">)]):</span>
                    <span class="n">found_all_types</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">futile_counter</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;did not manage to sample all target cell types&quot;</span><span class="p">)</span>
            <span class="n">node_type_names</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([</span>
                <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;sim_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">celldata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s2">&quot;node_type_names&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">node_type_map_idx</span><span class="p">)</span>
            <span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">celldata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s2">&quot;node_type_names&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_type_names</span>

            <span class="n">nfeatures</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">n_vars</span>
            <span class="c1"># Mean effect per simulated cell types:</span>
            <span class="n">effect_ct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n_target_cell_types</span><span class="p">,</span> <span class="n">nfeatures</span><span class="p">))</span>
            <span class="c1"># Create dependency structure of cell types.</span>
            <span class="c1"># Base line dependency structure with all dependencies as 0.</span>
            <span class="n">cov_ct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_target_cell_types</span><span class="p">,</span> <span class="n">n_target_cell_types</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">resimulate_nodes_w_depdency</span><span class="p">:</span>
                <span class="c1"># Add dependencies_per_type for each cell type:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_target_cell_types</span><span class="p">):</span>
                    <span class="c1"># Sample desired dependencies from non-self cell types:</span>
                    <span class="n">js</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_target_cell_types</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">ii</span><span class="p">],</span>
                                          <span class="n">size</span><span class="o">=</span><span class="n">dependencies_per_type</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">cov_ct</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">js</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
                <span class="c1"># Pairwise dependencies: Effect (self cell type, neighbor cell type, feature)</span>
                <span class="n">effect_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mf">4.</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mf">6.</span><span class="p">,</span>
                                                     <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n_target_cell_types</span><span class="p">,</span> <span class="n">n_target_cell_types</span><span class="p">,</span> <span class="n">nfeatures</span><span class="p">))</span>
                <span class="c1"># Simulate sparse effects:</span>
                <span class="n">sparsity_rate</span> <span class="o">=</span> <span class="n">resimulate_nodes_sparsity_rate</span>  <span class="c1"># fraction of zero effects</span>
                <span class="n">effect_neighbors</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">sparsity_rate</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">effect_neighbors</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mf">1.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">effect_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_target_cell_types</span><span class="p">,</span> <span class="n">n_target_cell_types</span><span class="p">,</span> <span class="n">nfeatures</span><span class="p">))</span>
            <span class="n">sigma_sq</span> <span class="o">=</span> <span class="mf">1.</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_simulation_parameters</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;effect_ct&quot;</span><span class="p">:</span> <span class="n">effect_ct</span><span class="p">,</span>
                <span class="s2">&quot;cov_ct&quot;</span><span class="p">:</span> <span class="n">cov_ct</span><span class="p">,</span>
                <span class="s2">&quot;effect_neighbors&quot;</span><span class="p">:</span> <span class="n">effect_neighbors</span><span class="p">,</span>
                <span class="s2">&quot;sigma_sq&quot;</span><span class="p">:</span> <span class="n">sigma_sq</span><span class="p">,</span>
                <span class="s2">&quot;adatas&quot;</span><span class="p">:</span> <span class="p">{}</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">ad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">adj</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">obsp</span><span class="p">[</span><span class="s1">&#39;adjacency_matrix_connectivities&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
                <span class="n">sim_ad</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">nobs</span> <span class="o">=</span> <span class="n">sim_ad</span><span class="o">.</span><span class="n">n_obs</span>
                <span class="c1"># Assign all cells from old cell type sets to corresponding new cell types, assumes one hot encoding.</span>
                <span class="n">sim_ad</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s2">&quot;node_types&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sim_ad</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s2">&quot;node_types&quot;</span><span class="p">][:,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">node_type_map_idx</span> <span class="o">==</span> <span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_target_cell_types</span><span class="p">)</span>
                <span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">sim_ad</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s2">&quot;node_types&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mf">1.</span><span class="p">)</span>
                <span class="c1"># Simulate count matrix:</span>
                <span class="n">dmat_ct</span> <span class="o">=</span> <span class="n">sim_ad</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s2">&quot;node_types&quot;</span><span class="p">]</span>
                <span class="n">loc_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nobs</span><span class="p">,</span> <span class="n">nfeatures</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nobs</span><span class="p">):</span>
                    <span class="n">ct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dmat_ct</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">==</span> <span class="mf">1.</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">ct</span> <span class="o">=</span> <span class="n">ct</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># flatten list of length 1</span>
                    <span class="n">dmat_neighhors_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_target_cell_types</span><span class="p">,))</span>
                    <span class="k">if</span> <span class="n">resimulate_nodes_w_depdency</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="n">ct_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dmat_ct</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">==</span> <span class="mf">1.</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">ct_j</span> <span class="o">=</span> <span class="n">ct_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># flatten list of length 1</span>
                            <span class="n">dmat_neighhors_i</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ct_j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
                    <span class="n">loc_neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">dmat_neighhors_i</span><span class="p">,</span> <span class="n">effect_neighbors</span><span class="p">[</span><span class="n">ct</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">dmat_ct</span><span class="p">,</span> <span class="n">effect_ct</span><span class="p">)</span> <span class="o">+</span> <span class="n">loc_neighbors</span>
                <span class="n">sim_ad</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma_sq</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">sim_ad</span>
                <span class="c1"># Record simulation:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_simulation_parameters</span><span class="p">[</span><span class="s2">&quot;adatas&quot;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;adj&quot;</span><span class="p">:</span> <span class="n">adj</span><span class="p">,</span>
                    <span class="s2">&quot;ct&quot;</span><span class="p">:</span> <span class="n">sim_ad</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s2">&quot;node_types&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">sim_ad</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                <span class="p">}</span>

            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Attention: Running simulation-based expression augmentation. </span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">This adjusts img_celldata, celldata remains unchanged.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Validate graph-wise covariate selection:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph_covar_selection</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">celldata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s2">&quot;graph_covariates&quot;</span><span class="p">][</span><span class="s2">&quot;label_selection&quot;</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">graph_covar_selection</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;could not find some sub-selected covar_selection </span><span class="si">%s</span><span class="s2"> in </span><span class="si">%s</span><span class="s2">&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">graph_covar_selection</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">celldata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s2">&quot;graph_covariates&quot;</span><span class="p">][</span><span class="s2">&quot;label_selection&quot;</span><span class="p">]))</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">img_to_patient_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">celldata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s2">&quot;img_to_patient_dict&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">complete_img_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">[</span><span class="s2">&quot;adjacency_matrix_connectivities&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adj_type</span> <span class="o">==</span> <span class="s2">&quot;scaled&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_transform_all_a</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node_label_space_id</span> <span class="o">==</span> <span class="s2">&quot;standard&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h_0</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">elif</span> <span class="n">node_label_space_id</span> <span class="o">==</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h_0</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s2">&quot;node_types&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">elif</span> <span class="n">node_label_space_id</span> <span class="o">==</span> <span class="s1">&#39;proportions&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h_0</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s2">&quot;proportions&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;node_label_space_id </span><span class="si">%s</span><span class="s2"> not recognized&quot;</span> <span class="o">%</span> <span class="n">node_label_space_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node_feature_space_id</span> <span class="o">==</span> <span class="s2">&quot;standard&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h_1</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">elif</span> <span class="n">node_feature_space_id</span> <span class="o">==</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h_1</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s2">&quot;node_types&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;node_feature_space_id </span><span class="si">%s</span><span class="s2"> not recognized&quot;</span> <span class="o">%</span> <span class="n">node_feature_space_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_types</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s2">&quot;node_types&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_type_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">celldata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s2">&quot;node_type_names&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_features_type</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_types</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_features_standard</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">celldata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_feature_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">celldata</span><span class="o">.</span><span class="n">var_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size_factors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">size_factors</span><span class="p">()</span>

        <span class="c1"># Add covariates:</span>
        <span class="c1"># Add graph-level covariate information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covar_selection</span> <span class="o">=</span> <span class="n">graph_covar_selection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_covar_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">celldata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s2">&quot;graph_covariates&quot;</span><span class="p">][</span><span class="s2">&quot;label_names&quot;</span><span class="p">]</span>

        <span class="c1"># Split loaded graph-wise covariates into labels (output, Y) and covariates / features (input, C)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph_covar_selection</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph_covar</span> <span class="o">=</span> <span class="p">{</span>  <span class="c1"># Single 1D array per observation: concatenate all covariates!</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s2">&quot;graph_covariates&quot;</span><span class="p">][</span><span class="s2">&quot;label_tensors&quot;</span><span class="p">][</span><span class="n">kk</span><span class="p">]</span> <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar_selection</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="c1"># Replace masked entries (np.nan) by zeros: (masking can be handled properly in output but not here):</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_covar</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">v</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">graph_covar</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Create empty covariate arrays:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph_covar</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="c1"># Add node-level conditional information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_covar</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">adata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="c1"># Cell position in image:</span>
        <span class="k">if</span> <span class="n">use_covar_node_position</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">complete_img_keys</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node_covar</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_covar</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s2">&quot;spatial&quot;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Position_matrix added to categorical predictor matrix&quot;</span><span class="p">)</span>
        <span class="c1"># Add graph-level covariates to node covariates:</span>
        <span class="k">if</span> <span class="n">use_covar_graph_covar</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">complete_img_keys</span><span class="p">:</span>
                <span class="c1"># Broadcast graph-level covariate to nodes:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_covar</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node_covar</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_covar</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Node_covar_selection broadcasted to categorical predictor matrix&quot;</span><span class="p">)</span>
        <span class="c1"># Add node</span>
        <span class="k">if</span> <span class="n">use_covar_node_label</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">complete_img_keys</span><span class="p">:</span>
                <span class="n">node_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s2">&quot;node_types&quot;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node_covar</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_covar</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">node_types</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Node_type added to categorical predictor matrix&quot;</span><span class="p">)</span>

        <span class="c1"># Set selection-specific tensor dimensions:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_features_0</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h_0</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_features_1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h_1</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_graph_covariates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_covar</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_node_covariates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_covar</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">complete_img_keys</span><span class="p">])</span>

        <span class="c1"># Define domains</span>
        <span class="k">if</span> <span class="n">domain_type</span> <span class="o">==</span> <span class="s2">&quot;image&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">domains</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">complete_img_keys</span><span class="p">)}</span>
        <span class="k">elif</span> <span class="n">domain_type</span> <span class="o">==</span> <span class="s2">&quot;patient&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">domains</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patient_ids_unique</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_to_patient_dict</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">complete_img_keys</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_domains</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domains</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">targeted_assay</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proportions</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proportions</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s2">&quot;proportions&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">img_celldata</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># Report summary statistics of loaded graph:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Mean of mean node degree per images across images: </span><span class="si">%f</span><span class="s2">&quot;</span>
            <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        <span class="p">)</span></div>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_get_dataset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">image_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">nodes_idx</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">shuffle_buffer_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">train</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">prefetch</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">reinit_n_eval</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prepare a dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        image_keys : np.array</span>
<span class="sd">            Image keys in partition.</span>
<span class="sd">        nodes_idx : dict, str</span>
<span class="sd">            Dictionary of nodes per image in partition.</span>
<span class="sd">        batch_size : int</span>
<span class="sd">            Batch size.</span>
<span class="sd">        shuffle_buffer_size : int, optional</span>
<span class="sd">            Shuffle buffer size.</span>
<span class="sd">        train : bool</span>
<span class="sd">            Whether dataset is used for training or not (influences shuffling of nodes).</span>
<span class="sd">        seed : int, optional</span>
<span class="sd">            Random seed.</span>
<span class="sd">        prefetch: int</span>
<span class="sd">            Prefetch of dataset.</span>
<span class="sd">        reinit_n_eval : int, optional</span>
<span class="sd">            Used if model is reinitialized to different number of nodes per graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_get_resampled_dataset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">image_keys</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">nodes_idx</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">prefetch</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate model based on resampled dataset for posterior resampling.</span>

<span class="sd">        node_1 + domain_1 -&gt; encoder -&gt; z_1 + domain_2 -&gt; decoder -&gt; reconstruction_2.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        image_keys: np.array</span>
<span class="sd">            Image keys in partition.</span>
<span class="sd">        nodes_idx : dict</span>
<span class="sd">            Dictionary of nodes per image in partition.</span>
<span class="sd">        batch_size : int</span>
<span class="sd">            Batch size.</span>
<span class="sd">        seed : int, optional</span>
<span class="sd">            Seed.</span>
<span class="sd">        prefetch : int</span>
<span class="sd">            Prefetch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="Estimator.init_model"><a class="viewcode-back" href="../../../api/ncem.estimators.Estimator.init_model.html#ncem.estimators.Estimator.init_model">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">init_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize and compiles the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs</span>
<span class="sd">            Arbitrary keyword arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">patient_ids_bytarget</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return patient identifiers by target.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        patient_ids_bytarget</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">img_to_patient_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">complete_img_keys</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">patient_ids_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return unique patient identifiers.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        patient_ids_unique</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patient_ids_bytarget</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">img_keys_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all image keys.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        img_keys_all</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">img_keys_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_keys_eval</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_keys_test</span><span class="p">]))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nodes_idx_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all node indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nodes_idx_all</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                            <span class="p">[</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_train</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_train</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_eval</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_eval</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_test</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_test</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
                            <span class="p">]</span>
                        <span class="p">)</span>
                    <span class="p">),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_keys_all</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_prepare_sf</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prepare size factors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x</span>
<span class="sd">            Inout array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        size_factors</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            x.shape &gt; 2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x.shape &gt; 2&quot;</span><span class="p">)</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="n">sf</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sf</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sf</span>

    <span class="k">def</span> <span class="nf">_compile_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">optimizers</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">,</span> <span class="n">output_layer</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compile all necessary models.</span>

<span class="sd">        ATTENTION: Decoder compiled with same optimizer instance as training model if an instance is passed!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        optimizer : tf.keras.optimizers.Optimizer</span>
<span class="sd">            Optimizer to be used for training model (and decoder).</span>
<span class="sd">        output_layer : str</span>
<span class="sd">            Output layer to be used (e.g. gaussian).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `output_layer` is not recognized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vi_model</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># variational inference</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cvae&quot;</span><span class="p">,</span> <span class="s2">&quot;cvae_ncem&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vi_model</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">enc_dec_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;cvae&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;cvae_ncem&quot;</span>

        <span class="k">if</span> <span class="n">output_layer</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,</span> <span class="s2">&quot;gaussian_const_disp&quot;</span><span class="p">,</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;linear_const_disp&quot;</span><span class="p">]:</span>
            <span class="n">reconstruction_loss</span> <span class="o">=</span> <span class="n">GaussianLoss</span><span class="p">()</span>
            <span class="n">reconstruction_metrics</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">custom_mae</span><span class="p">,</span>
                <span class="n">custom_mean_sd</span><span class="p">,</span>
                <span class="n">custom_mse</span><span class="p">,</span>
                <span class="n">custom_mse_scaled</span><span class="p">,</span>
                <span class="n">gaussian_reconstruction_loss</span><span class="p">,</span>
                <span class="n">r_squared</span><span class="p">,</span>
                <span class="n">r_squared_linreg</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="k">elif</span> <span class="n">output_layer</span> <span class="o">==</span> <span class="s2">&quot;nb&quot;</span> <span class="ow">or</span> <span class="n">output_layer</span> <span class="o">==</span> <span class="s2">&quot;nb_shared_disp&quot;</span> <span class="ow">or</span> <span class="n">output_layer</span> <span class="o">==</span> <span class="s2">&quot;nb_const_disp&quot;</span><span class="p">:</span>
            <span class="n">reconstruction_loss</span> <span class="o">=</span> <span class="n">NegBinLoss</span><span class="p">()</span>
            <span class="n">reconstruction_metrics</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">custom_mae</span><span class="p">,</span>
                <span class="n">custom_mean_sd</span><span class="p">,</span>
                <span class="n">nb_reconstruction_loss</span><span class="p">,</span>
                <span class="n">logp1_custom_mse</span><span class="p">,</span>
                <span class="n">logp1_r_squared</span><span class="p">,</span>
                <span class="n">logp1_r_squared_linreg</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;output_layer </span><span class="si">%s</span><span class="s2"> not recognized&quot;</span> <span class="o">%</span> <span class="n">output_layer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_layer</span> <span class="o">=</span> <span class="n">output_layer</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi_model</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loss</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">reconstruction_loss</span><span class="p">,</span>
                <span class="n">KLLoss</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span> <span class="n">max_beta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_beta</span><span class="p">,</span> <span class="n">pre_warm_up</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pre_warm_up</span><span class="p">),</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span> <span class="o">=</span> <span class="p">[</span><span class="n">reconstruction_metrics</span><span class="p">,</span> <span class="p">[</span><span class="n">custom_kl</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loss</span> <span class="o">=</span> <span class="p">[</span><span class="n">reconstruction_loss</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span> <span class="o">=</span> <span class="n">reconstruction_metrics</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">training_model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metrics</span><span class="p">)</span>
        <span class="c1"># Also compile sampling model / decoder if available:</span>
        <span class="k">if</span> <span class="n">enc_dec_model</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metrics</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi_model</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">decoder_sampling</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metrics</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_remove_unidentified_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_idx</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Exclude undefined cells from data set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_idx</span>
<span class="sd">            Data set to remove unidentified nodes from.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            number of unidentifed nodes removed, data set with unidentified nodes removed from.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">undefined_node_types</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Identify cells with undefined cell_type in all target images</span>
            <span class="n">undefined_label_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">([</span><span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">undefined_node_types</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_type_names</span><span class="o">.</span><span class="n">values</span><span class="p">()])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Extract shape and number for print statement</span>
            <span class="n">n_undefined_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_types</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">v</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">undefined_label_idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">node_idx</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="n">node_idx</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_types</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">v</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">undefined_label_idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))[</span>
                            <span class="mi">0</span>
                        <span class="p">]</span>
                    <span class="p">]</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">node_idx</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_undefined_nodes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">n_undefined_nodes</span><span class="p">,</span> <span class="n">node_idx</span>

<div class="viewcode-block" id="Estimator.split_data_given"><a class="viewcode-back" href="../../../api/ncem.estimators.Estimator.split_data_given.html#ncem.estimators.Estimator.split_data_given">[docs]</a>    <span class="k">def</span> <span class="nf">split_data_given</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">img_keys_test</span><span class="p">,</span> <span class="n">img_keys_train</span><span class="p">,</span> <span class="n">img_keys_eval</span><span class="p">,</span> <span class="n">nodes_idx_test</span><span class="p">,</span> <span class="n">nodes_idx_train</span><span class="p">,</span> <span class="n">nodes_idx_eval</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Split data by given partition.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        img_keys_test</span>
<span class="sd">            Test image keys.</span>
<span class="sd">        img_keys_train</span>
<span class="sd">            Train image keys.</span>
<span class="sd">        img_keys_eval</span>
<span class="sd">            Evaluation image keys.</span>
<span class="sd">        nodes_idx_test</span>
<span class="sd">            Test node indices.</span>
<span class="sd">        nodes_idx_train</span>
<span class="sd">            Train node indices.</span>
<span class="sd">        nodes_idx_eval</span>
<span class="sd">            Evaluation node indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">img_keys_test</span> <span class="o">=</span> <span class="n">img_keys_test</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">img_keys_train</span> <span class="o">=</span> <span class="n">img_keys_train</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">img_keys_eval</span> <span class="o">=</span> <span class="n">img_keys_eval</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_test</span> <span class="o">=</span> <span class="n">nodes_idx_test</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_train</span> <span class="o">=</span> <span class="n">nodes_idx_train</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_eval</span> <span class="o">=</span> <span class="n">nodes_idx_eval</span></div>

<div class="viewcode-block" id="Estimator.split_data_node"><a class="viewcode-back" href="../../../api/ncem.estimators.Estimator.split_data_node.html#ncem.estimators.Estimator.split_data_node">[docs]</a>    <span class="k">def</span> <span class="nf">split_data_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test_split</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">validation_split</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Split nodes randomly into partitions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test_split : float</span>
<span class="sd">            Fraction of total nodes to be in test set.</span>
<span class="sd">        validation_split : float</span>
<span class="sd">            Fraction of train-eval nodes to be in validation split.</span>
<span class="sd">        seed : int</span>
<span class="sd">            Seed for random selection of observations.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If evaluation or test dataset are empty.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Using split method: node. </span><span class="se">\n</span><span class="s2"> Train-test-validation split is based on total number of nodes &quot;</span>
            <span class="s2">&quot;per patients over all images.&quot;</span>
        <span class="p">)</span>

        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="n">h_nodes_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_0</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">all_nodes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">h_nodes_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">nodes_all_idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">h_nodes_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">img_keys_test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">complete_img_keys</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">img_keys_train</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">complete_img_keys</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">img_keys_eval</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">complete_img_keys</span><span class="p">)</span>

        <span class="n">n_undefined_nodes</span><span class="p">,</span> <span class="n">nodes_all_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_unidentified_nodes</span><span class="p">(</span><span class="n">node_idx</span><span class="o">=</span><span class="n">nodes_all_idx</span><span class="p">)</span>
        <span class="c1"># updating h_nodes_dict to only include the number of identified cells</span>
        <span class="n">h_nodes_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">nodes_all_idx</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># Do Test-Val-Train split by patients and put all images for a patient into the chosen partition:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">test_split</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">test_split</span> <span class="o">==</span> <span class="s2">&quot;one sample&quot;</span><span class="p">:</span>
            <span class="n">h_test_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">h_nodes_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">h_test_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">test_split</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">h_nodes_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_test</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">nodes_all_idx</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">h_test_dict</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_0</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">nodes_idx_test_shapes</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_test</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">test_nodes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nodes_idx_test_shapes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="n">nodes_idx_train_eval</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">i</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nodes_all_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_test</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_0</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_eval</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">i</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">nodes_idx_train_eval</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="nb">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes_idx_train_eval</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">validation_split</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_0</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">nodes_idx_eval_shapes</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_eval</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">eval_nodes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nodes_idx_eval_shapes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_train</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">i</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nodes_idx_train_eval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_eval</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_0</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">nodes_idx_train_shapes</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_train</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">train_nodes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nodes_idx_train_shapes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Excluded </span><span class="si">%i</span><span class="s2"> cells with the following unannotated cell type: [</span><span class="si">%s</span><span class="s2">] </span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Whole dataset: </span><span class="si">%i</span><span class="s2"> cells out of </span><span class="si">%i</span><span class="s2"> images from </span><span class="si">%i</span><span class="s2"> patients.&quot;</span>
            <span class="o">%</span> <span class="p">(</span>
                <span class="n">n_undefined_nodes</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">undefined_node_types</span><span class="p">,</span>
                <span class="n">all_nodes</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">complete_img_keys</span><span class="p">)),</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patient_ids_unique</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Test dataset: </span><span class="si">%i</span><span class="s2"> cells out of </span><span class="si">%i</span><span class="s2"> images from </span><span class="si">%i</span><span class="s2"> patients.&quot;</span>
            <span class="o">%</span> <span class="p">(</span>
                <span class="n">test_nodes</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_keys_test</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patient_ids_unique</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Training dataset: </span><span class="si">%i</span><span class="s2"> cells out of </span><span class="si">%i</span><span class="s2"> images from </span><span class="si">%i</span><span class="s2"> patients.&quot;</span>
            <span class="o">%</span> <span class="p">(</span>
                <span class="n">train_nodes</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_keys_train</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patient_ids_unique</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Validation dataset: </span><span class="si">%i</span><span class="s2"> cells out of </span><span class="si">%i</span><span class="s2"> images from </span><span class="si">%i</span><span class="s2"> patients. </span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">%</span> <span class="p">(</span>
                <span class="n">eval_nodes</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_keys_eval</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patient_ids_unique</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Check that none of the train, eval partitions are empty</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">eval_nodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The evaluation dataset is empty.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">train_nodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The train dataset is empty.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Estimator.split_data_target_cell"><a class="viewcode-back" href="../../../api/ncem.estimators.Estimator.split_data_target_cell.html#ncem.estimators.Estimator.split_data_target_cell">[docs]</a>    <span class="k">def</span> <span class="nf">split_data_target_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_cell</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">test_split</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">validation_split</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Split nodes randomly into partitions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target_cell : str</span>
<span class="sd">            Target cell type.</span>
<span class="sd">        test_split : float</span>
<span class="sd">            Fraction of total nodes to be in test set.</span>
<span class="sd">        validation_split : float</span>
<span class="sd">            Fraction of train-eval nodes to be in validation split.</span>
<span class="sd">        seed : int</span>
<span class="sd">            Seed for random selection of observations.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If evaluation or test dataset are empty.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Using split method: target cell. </span><span class="se">\n</span><span class="s2"> Train-test-validation split is based on total number of nodes &quot;</span>
            <span class="s2">&quot;per patients over all images.&quot;</span>
        <span class="p">)</span>

        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="n">h_nodes_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_0</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">all_nodes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">h_nodes_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">nodes_all_idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">h_nodes_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="n">target_cell_id</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_type_names</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">target_cell</span><span class="p">)</span>

        <span class="c1"># Assign images to partitions:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">img_keys_train</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">complete_img_keys</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">img_keys_eval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_keys_train</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">img_keys_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_keys_train</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">n_undefined_nodes</span><span class="p">,</span> <span class="n">nodes_all_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_unidentified_nodes</span><span class="p">(</span><span class="n">node_idx</span><span class="o">=</span><span class="n">nodes_all_idx</span><span class="p">)</span>

        <span class="c1"># Dictionary of all nodes within a target cell type</span>
        <span class="n">nodes_all_idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_types</span><span class="p">[</span><span class="n">k</span><span class="p">][:,</span> <span class="n">target_cell_id</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_keys_train</span><span class="p">}</span>
        <span class="c1"># updating h_nodes_dict to only include the number of identified cells of specific target cell</span>
        <span class="n">h_nodes_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">nodes_all_idx</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="n">nodes_all_idx_shapes</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">nodes_all_idx</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">target_cell_nodes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nodes_all_idx_shapes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="c1"># Do Test-Val-Train split by patients and put all images for a patient into the chosen partition:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">test_split</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">test_split</span> <span class="o">==</span> <span class="s2">&quot;one sample&quot;</span><span class="p">:</span>
            <span class="n">h_test_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">h_nodes_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">h_test_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">test_split</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">h_nodes_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># Assign nodes to partitions:</span>
        <span class="c1"># Test partition:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_test</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">nodes_all_idx</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">h_test_dict</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_0</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">nodes_idx_test_shapes</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_test</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">test_nodes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nodes_idx_test_shapes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="c1"># Define train-eval partition:</span>
        <span class="n">nodes_idx_train_eval</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">i</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nodes_all_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_test</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_0</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="c1"># Randomly partition train-eval into train and eval:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_eval</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">i</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">nodes_idx_train_eval</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="nb">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes_idx_train_eval</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">validation_split</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_0</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">nodes_idx_eval_shapes</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_eval</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">eval_nodes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nodes_idx_eval_shapes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="c1"># Assign all nodes in train-eval that are not assigned to eval to train:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_train</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">i</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nodes_idx_train_eval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_eval</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_0</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">nodes_idx_train_shapes</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_train</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">train_nodes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nodes_idx_train_shapes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Excluded </span><span class="si">%i</span><span class="s2"> cells with the following unannotated cell type: [</span><span class="si">%s</span><span class="s2">] </span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Whole dataset: </span><span class="si">%i</span><span class="s2"> cells out of </span><span class="si">%i</span><span class="s2"> images from </span><span class="si">%i</span><span class="s2"> patients.&quot;</span>
            <span class="o">%</span> <span class="p">(</span>
                <span class="n">n_undefined_nodes</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">undefined_node_types</span><span class="p">,</span>
                <span class="n">all_nodes</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">complete_img_keys</span><span class="p">)),</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patient_ids_unique</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Cell type used for training </span><span class="si">%s</span><span class="s2">: </span><span class="si">%i</span><span class="s2"> cells out of </span><span class="si">%i</span><span class="s2"> images from </span><span class="si">%i</span><span class="s2"> patients. &quot;</span>
            <span class="o">%</span> <span class="p">(</span>
                <span class="n">target_cell</span><span class="p">,</span>
                <span class="n">target_cell_nodes</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">complete_img_keys</span><span class="p">)),</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patient_ids_unique</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Test dataset: </span><span class="si">%i</span><span class="s2"> cells out of </span><span class="si">%i</span><span class="s2"> images from </span><span class="si">%i</span><span class="s2"> patients. &quot;</span>
            <span class="o">%</span> <span class="p">(</span>
                <span class="n">test_nodes</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_keys_test</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patient_ids_unique</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Training dataset: </span><span class="si">%i</span><span class="s2"> cells out of </span><span class="si">%i</span><span class="s2"> images from </span><span class="si">%i</span><span class="s2"> patients.&quot;</span>
            <span class="o">%</span> <span class="p">(</span>
                <span class="n">train_nodes</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_keys_train</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patient_ids_unique</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Validation dataset: </span><span class="si">%i</span><span class="s2"> cells out of </span><span class="si">%i</span><span class="s2"> images from </span><span class="si">%i</span><span class="s2"> patients.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">%</span> <span class="p">(</span>
                <span class="n">eval_nodes</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_keys_eval</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patient_ids_unique</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Check that none of the train, eval partitions are empty</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">eval_nodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The evaluation dataset is empty.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">train_nodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The train dataset is empty.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Estimator.train"><a class="viewcode-back" href="../../../api/ncem.estimators.Estimator.train.html#ncem.estimators.Estimator.train">[docs]</a>    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">epochs_warmup</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">max_steps_per_epoch</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
        <span class="n">validation_batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
        <span class="n">max_validation_steps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">shuffle_buffer_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e4</span><span class="p">),</span>
        <span class="n">patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
        <span class="n">lr_schedule_min_lr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span>
        <span class="n">lr_schedule_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">lr_schedule_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">initial_epoch</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">monitor_partition</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;val&quot;</span><span class="p">,</span>
        <span class="n">monitor_metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">log_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">callbacks</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">early_stopping</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">reduce_lr_plateau</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pretrain_decoder</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">decoder_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">decoder_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
        <span class="n">decoder_callbacks</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">aggressive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">aggressive_enc_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">aggressive_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1234</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Train model.</span>

<span class="sd">        Use validation loss and maximum number of epochs as termination criteria.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        epochs : int</span>
<span class="sd">            Integer number of times to iterate over the training data arrays. If unspecified, it will default to 1000.</span>
<span class="sd">        epochs_warmup : int</span>
<span class="sd">            Integer number of times to iterate over the training data arrays in warm up (without early stopping). If</span>
<span class="sd">            unspecified, it will default to 0.</span>
<span class="sd">        max_steps_per_epoch : int, optional</span>
<span class="sd">            Maximal steps per epoch. If unspecified, it will default to 20.</span>
<span class="sd">        batch_size : int</span>
<span class="sd">            Number of samples per gradient update. If unspecified, it will default to 16.</span>
<span class="sd">        validation_batch_size : int</span>
<span class="sd">            Number of samples in validation. If unspecified, it will default to 16.</span>
<span class="sd">        max_validation_steps : int</span>
<span class="sd">            Maximal steps per validation. If unspecified, it will default to 10.</span>
<span class="sd">        shuffle_buffer_size : int, optional</span>
<span class="sd">            Shuffle buffer size. If unspecified, it will default to 1e4.</span>
<span class="sd">        patience : int</span>
<span class="sd">            Number of epochs with no improvement. If unspecified, it will default to 20.</span>
<span class="sd">        lr_schedule_min_lr : float</span>
<span class="sd">            Lower bound on the learning rate. If unspecified, it will default to 1e-5.</span>
<span class="sd">        lr_schedule_factor : float</span>
<span class="sd">            Factor by which the learning rate will be reduced. new_lr = lr * factor. If unspecified, it will default</span>
<span class="sd">            to 0.2.</span>
<span class="sd">        lr_schedule_patience : int</span>
<span class="sd">            Number of epochs with no improvement after which learning rate will be reduced. If unspecified, it will</span>
<span class="sd">            default to 5.</span>
<span class="sd">        initial_epoch : int</span>
<span class="sd">            Epoch at which to start training (useful for resuming a previous training run). If unspecified, it will</span>
<span class="sd">            default to 0.</span>
<span class="sd">        monitor_partition : str</span>
<span class="sd">            Monitor partition.</span>
<span class="sd">        monitor_metric : str</span>
<span class="sd">            Monitor metric.</span>
<span class="sd">        log_dir : str, optional</span>
<span class="sd">            Logging directory.</span>
<span class="sd">        callbacks : list, optional</span>
<span class="sd">             List of callbacks to be called during training.</span>
<span class="sd">        early_stopping : bool</span>
<span class="sd">            Whether to activate early stopping.</span>
<span class="sd">        reduce_lr_plateau : bool</span>
<span class="sd">            Whether to reduce learning rate on plateau.</span>
<span class="sd">        pretrain_decoder : bool</span>
<span class="sd">            Whether to pretrain the decoder model.</span>
<span class="sd">        decoder_epochs : int</span>
<span class="sd">            Integer number of times to iterate over the training data arrays in decoder pretraining. If unspecified, it</span>
<span class="sd">            will default to 1000.</span>
<span class="sd">        decoder_patience : int</span>
<span class="sd">            Number of epochs with no improvement in decoder pretraining. If unspecified, it will default to 20.</span>
<span class="sd">        decoder_callbacks : list, optional</span>
<span class="sd">             List of callbacks to be called during decoder pretraining.</span>
<span class="sd">        aggressive : bool</span>
<span class="sd">            Whether to train aggressive.</span>
<span class="sd">        aggressive_enc_patience : int</span>
<span class="sd">             Number of epochs with no improvement in aggressive training. If unspecified, it will default to 10.</span>
<span class="sd">        aggressive_epochs : int</span>
<span class="sd">            Integer number of times to iterate over the training data arrays in aggressive training. If unspecified, it</span>
<span class="sd">            will default to 5.</span>
<span class="sd">        seed : int</span>
<span class="sd">            Random seed for reproduability.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Arbitrary keyword arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Save training settings to allow model restoring.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_hyperparam</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;epochs&quot;</span><span class="p">:</span> <span class="n">epochs</span><span class="p">,</span>
            <span class="s2">&quot;epochs_warmup&quot;</span><span class="p">:</span> <span class="n">epochs_warmup</span><span class="p">,</span>
            <span class="s2">&quot;max_steps_per_epoch&quot;</span><span class="p">:</span> <span class="n">max_steps_per_epoch</span><span class="p">,</span>
            <span class="s2">&quot;batch_size&quot;</span><span class="p">:</span> <span class="n">batch_size</span><span class="p">,</span>
            <span class="s2">&quot;validation_batch_size&quot;</span><span class="p">:</span> <span class="n">validation_batch_size</span><span class="p">,</span>
            <span class="s2">&quot;max_validation_steps&quot;</span><span class="p">:</span> <span class="n">max_validation_steps</span><span class="p">,</span>
            <span class="s2">&quot;shuffle_buffer_size&quot;</span><span class="p">:</span> <span class="n">shuffle_buffer_size</span><span class="p">,</span>
            <span class="s2">&quot;patience&quot;</span><span class="p">:</span> <span class="n">patience</span><span class="p">,</span>
            <span class="s2">&quot;lr_schedule_min_lr&quot;</span><span class="p">:</span> <span class="n">lr_schedule_min_lr</span><span class="p">,</span>
            <span class="s2">&quot;lr_schedule_factor&quot;</span><span class="p">:</span> <span class="n">lr_schedule_factor</span><span class="p">,</span>
            <span class="s2">&quot;lr_schedule_patience&quot;</span><span class="p">:</span> <span class="n">lr_schedule_patience</span><span class="p">,</span>
            <span class="s2">&quot;log_dir&quot;</span><span class="p">:</span> <span class="n">log_dir</span><span class="p">,</span>
            <span class="s2">&quot;pretrain_decoder&quot;</span><span class="p">:</span> <span class="n">pretrain_decoder</span><span class="p">,</span>
            <span class="s2">&quot;decoder_epochs&quot;</span><span class="p">:</span> <span class="n">decoder_epochs</span><span class="p">,</span>
            <span class="s2">&quot;decoder_patience&quot;</span><span class="p">:</span> <span class="n">decoder_patience</span><span class="p">,</span>
            <span class="s2">&quot;aggressive&quot;</span><span class="p">:</span> <span class="n">aggressive</span><span class="p">,</span>
            <span class="s2">&quot;aggressive_enc_patience&quot;</span><span class="p">:</span> <span class="n">aggressive_enc_patience</span><span class="p">,</span>
            <span class="s2">&quot;aggressive_epochs&quot;</span><span class="p">:</span> <span class="n">aggressive_epochs</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_dataset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dataset</span><span class="p">(</span>
            <span class="n">image_keys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">img_keys_train</span><span class="p">,</span>
            <span class="n">nodes_idx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_train</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">shuffle_buffer_size</span><span class="o">=</span><span class="n">shuffle_buffer_size</span><span class="p">,</span>
            <span class="n">train</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
            <span class="n">reinit_n_eval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eval_dataset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dataset</span><span class="p">(</span>
            <span class="n">image_keys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">img_keys_eval</span><span class="p">,</span>
            <span class="n">nodes_idx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_eval</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">validation_batch_size</span><span class="p">,</span>
            <span class="n">shuffle_buffer_size</span><span class="o">=</span><span class="n">shuffle_buffer_size</span><span class="p">,</span>
            <span class="n">train</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
            <span class="n">reinit_n_eval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">steps_per_epoch</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_keys_train</span><span class="p">)</span> <span class="o">//</span> <span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">max_steps_per_epoch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validation_steps</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_keys_eval</span><span class="p">)</span> <span class="o">//</span> <span class="n">validation_batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">max_validation_steps</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pretrain_decoder</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pretrain_decoder</span><span class="p">(</span>
                <span class="n">decoder_epochs</span><span class="o">=</span><span class="n">decoder_epochs</span><span class="p">,</span>
                <span class="n">patience</span><span class="o">=</span><span class="n">decoder_patience</span><span class="p">,</span>
                <span class="n">lr_schedule_min_lr</span><span class="o">=</span><span class="n">lr_schedule_min_lr</span><span class="p">,</span>
                <span class="n">lr_schedule_factor</span><span class="o">=</span><span class="n">lr_schedule_factor</span><span class="p">,</span>
                <span class="n">lr_schedule_patience</span><span class="o">=</span><span class="n">lr_schedule_patience</span><span class="p">,</span>
                <span class="n">initial_epoch</span><span class="o">=</span><span class="n">initial_epoch</span><span class="p">,</span>
                <span class="n">monitor_partition</span><span class="o">=</span><span class="n">monitor_partition</span><span class="p">,</span>
                <span class="n">monitor_metric</span><span class="o">=</span><span class="n">monitor_metric</span><span class="p">,</span>
                <span class="n">log_dir</span><span class="o">=</span><span class="n">log_dir</span><span class="p">,</span>
                <span class="n">callbacks</span><span class="o">=</span><span class="n">decoder_callbacks</span><span class="p">,</span>
                <span class="n">early_stopping</span><span class="o">=</span><span class="n">early_stopping</span><span class="p">,</span>
                <span class="n">reduce_lr_plateau</span><span class="o">=</span><span class="n">reduce_lr_plateau</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">aggressive</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train_aggressive</span><span class="p">(</span><span class="n">aggressive_enc_patience</span><span class="o">=</span><span class="n">aggressive_enc_patience</span><span class="p">,</span> <span class="n">aggressive_epochs</span><span class="o">=</span><span class="n">aggressive_epochs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">epochs_warmup</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train_normal</span><span class="p">(</span>
                <span class="n">epochs</span><span class="o">=</span><span class="n">epochs_warmup</span><span class="p">,</span>
                <span class="n">patience</span><span class="o">=</span><span class="n">patience</span><span class="p">,</span>
                <span class="n">lr_schedule_min_lr</span><span class="o">=</span><span class="n">lr_schedule_min_lr</span><span class="p">,</span>
                <span class="n">lr_schedule_factor</span><span class="o">=</span><span class="n">lr_schedule_factor</span><span class="p">,</span>
                <span class="n">lr_schedule_patience</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">10000</span><span class="p">),</span>  <span class="c1"># dont reduce</span>
                <span class="n">initial_epoch</span><span class="o">=</span><span class="n">initial_epoch</span><span class="p">,</span>
                <span class="n">monitor_partition</span><span class="o">=</span><span class="n">monitor_partition</span><span class="p">,</span>
                <span class="n">monitor_metric</span><span class="o">=</span><span class="n">monitor_metric</span><span class="p">,</span>
                <span class="n">log_dir</span><span class="o">=</span><span class="n">log_dir</span><span class="p">,</span>
                <span class="n">callbacks</span><span class="o">=</span><span class="n">callbacks</span><span class="p">,</span>
                <span class="n">early_stopping</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">reduce_lr_plateau</span><span class="o">=</span><span class="n">reduce_lr_plateau</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">initial_epoch</span> <span class="o">+=</span> <span class="n">epochs_warmup</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">train_normal</span><span class="p">(</span>
            <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
            <span class="n">patience</span><span class="o">=</span><span class="n">patience</span><span class="p">,</span>
            <span class="n">lr_schedule_min_lr</span><span class="o">=</span><span class="n">lr_schedule_min_lr</span><span class="p">,</span>
            <span class="n">lr_schedule_factor</span><span class="o">=</span><span class="n">lr_schedule_factor</span><span class="p">,</span>
            <span class="n">lr_schedule_patience</span><span class="o">=</span><span class="n">lr_schedule_patience</span><span class="p">,</span>
            <span class="n">initial_epoch</span><span class="o">=</span><span class="n">initial_epoch</span><span class="p">,</span>
            <span class="n">monitor_partition</span><span class="o">=</span><span class="n">monitor_partition</span><span class="p">,</span>
            <span class="n">monitor_metric</span><span class="o">=</span><span class="n">monitor_metric</span><span class="p">,</span>
            <span class="n">log_dir</span><span class="o">=</span><span class="n">log_dir</span><span class="p">,</span>
            <span class="n">callbacks</span><span class="o">=</span><span class="n">callbacks</span><span class="p">,</span>
            <span class="n">early_stopping</span><span class="o">=</span><span class="n">early_stopping</span><span class="p">,</span>
            <span class="n">reduce_lr_plateau</span><span class="o">=</span><span class="n">reduce_lr_plateau</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Estimator.train_normal"><a class="viewcode-back" href="../../../api/ncem.estimators.Estimator.train_normal.html#ncem.estimators.Estimator.train_normal">[docs]</a>    <span class="k">def</span> <span class="nf">train_normal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
        <span class="n">lr_schedule_min_lr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span>
        <span class="n">lr_schedule_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">lr_schedule_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">initial_epoch</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">monitor_partition</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;val&quot;</span><span class="p">,</span>
        <span class="n">monitor_metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">log_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">callbacks</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">early_stopping</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">reduce_lr_plateau</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Train model normal.</span>

<span class="sd">        Use validation loss and maximum number of epochs as termination criteria.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        epochs : int</span>
<span class="sd">            Integer number of times to iterate over the training data arrays. If unspecified, it will default to 1000.</span>
<span class="sd">        patience : int</span>
<span class="sd">            Number of epochs with no improvement. If unspecified, it will default to 20.</span>
<span class="sd">        lr_schedule_min_lr : float</span>
<span class="sd">            Lower bound on the learning rate. If unspecified, it will default to 1e-5.</span>
<span class="sd">        lr_schedule_factor : float</span>
<span class="sd">            Factor by which the learning rate will be reduced. new_lr = lr * factor. If unspecified, it will default</span>
<span class="sd">            to 0.2.</span>
<span class="sd">        lr_schedule_patience : int</span>
<span class="sd">            Number of epochs with no improvement after which learning rate will be reduced. If unspecified, it will</span>
<span class="sd">            default to 5.</span>
<span class="sd">        initial_epoch : int</span>
<span class="sd">            Epoch at which to start training (useful for resuming a previous training run). If unspecified, it will</span>
<span class="sd">            default to 0.</span>
<span class="sd">        monitor_partition : str</span>
<span class="sd">            Monitor partition.</span>
<span class="sd">        monitor_metric : str</span>
<span class="sd">            Monitor metric.</span>
<span class="sd">        log_dir : str, optional</span>
<span class="sd">            Logging directory.</span>
<span class="sd">        callbacks : list, optional</span>
<span class="sd">             List of callbacks to be called during training.</span>
<span class="sd">        early_stopping : bool</span>
<span class="sd">            Whether to activate early stopping.</span>
<span class="sd">        reduce_lr_plateau : bool</span>
<span class="sd">            Whether to reduce learning rate on plateau.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Arbitrary keyword arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set callbacks.</span>
        <span class="n">cbs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">reduce_lr_plateau</span><span class="p">:</span>
            <span class="n">cbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">ReduceLROnPlateau</span><span class="p">(</span>
                    <span class="n">monitor</span><span class="o">=</span><span class="n">monitor_partition</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">monitor_metric</span><span class="p">,</span>
                    <span class="n">factor</span><span class="o">=</span><span class="n">lr_schedule_factor</span><span class="p">,</span>
                    <span class="n">patience</span><span class="o">=</span><span class="n">lr_schedule_patience</span><span class="p">,</span>
                    <span class="n">min_lr</span><span class="o">=</span><span class="n">lr_schedule_min_lr</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">early_stopping</span><span class="p">:</span>
            <span class="n">cbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">EarlyStopping</span><span class="p">(</span>
                    <span class="n">monitor</span><span class="o">=</span><span class="n">monitor_partition</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">monitor_metric</span><span class="p">,</span> <span class="n">patience</span><span class="o">=</span><span class="n">patience</span><span class="p">,</span> <span class="n">restore_best_weights</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">log_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">TensorBoard</span><span class="p">(</span>
                    <span class="n">log_dir</span><span class="o">=</span><span class="n">log_dir</span><span class="p">,</span>
                    <span class="n">histogram_freq</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">write_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">write_grads</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">write_images</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">embeddings_freq</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">embeddings_layer_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">embeddings_metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">embeddings_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">update_freq</span><span class="o">=</span><span class="s2">&quot;epoch&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">callbacks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># callbacks needs to be a list</span>
            <span class="n">cbs</span> <span class="o">+=</span> <span class="n">callbacks</span>

        <span class="n">history</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">training_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">train_dataset</span><span class="p">,</span>
            <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
            <span class="n">initial_epoch</span><span class="o">=</span><span class="n">initial_epoch</span><span class="p">,</span>
            <span class="n">steps_per_epoch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">steps_per_epoch</span><span class="p">,</span>
            <span class="n">callbacks</span><span class="o">=</span><span class="n">cbs</span><span class="p">,</span>
            <span class="n">validation_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eval_dataset</span><span class="p">,</span>
            <span class="n">validation_steps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">validation_steps</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">history</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">history</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  <span class="c1"># append to history if train() has been called before.</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span></div>

<div class="viewcode-block" id="Estimator.pretrain_decoder"><a class="viewcode-back" href="../../../api/ncem.estimators.Estimator.pretrain_decoder.html#ncem.estimators.Estimator.pretrain_decoder">[docs]</a>    <span class="k">def</span> <span class="nf">pretrain_decoder</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">decoder_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
        <span class="n">lr_schedule_min_lr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span>
        <span class="n">lr_schedule_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">lr_schedule_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">initial_epoch</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">monitor_partition</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;val&quot;</span><span class="p">,</span>
        <span class="n">monitor_metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">log_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">callbacks</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">early_stopping</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">reduce_lr_plateau</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pre-train decoder model.</span>

<span class="sd">        Use validation loss and maximum number of epochs as termination criteria.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        patience : int</span>
<span class="sd">            Number of epochs with no improvement. If unspecified, it will default to 20.</span>
<span class="sd">        lr_schedule_min_lr : float</span>
<span class="sd">            Lower bound on the learning rate. If unspecified, it will default to 1e-5.</span>
<span class="sd">        lr_schedule_factor : float</span>
<span class="sd">            Factor by which the learning rate will be reduced. new_lr = lr * factor. If unspecified, it will default</span>
<span class="sd">            to 0.2.</span>
<span class="sd">        lr_schedule_patience : int</span>
<span class="sd">            Number of epochs with no improvement after which learning rate will be reduced. If unspecified, it will</span>
<span class="sd">            default to 5.</span>
<span class="sd">        initial_epoch : int</span>
<span class="sd">            Epoch at which to start training (useful for resuming a previous training run). If unspecified, it will</span>
<span class="sd">            default to 0.</span>
<span class="sd">        monitor_partition : str</span>
<span class="sd">            Monitor partition.</span>
<span class="sd">        monitor_metric : str</span>
<span class="sd">            Monitor metric.</span>
<span class="sd">        log_dir : str, optional</span>
<span class="sd">            Logging directory.</span>
<span class="sd">        callbacks : list, optional</span>
<span class="sd">             List of callbacks to be called during training.</span>
<span class="sd">        early_stopping : bool</span>
<span class="sd">            Whether to activate early stopping.</span>
<span class="sd">        reduce_lr_plateau : bool</span>
<span class="sd">            Whether to reduce learning rate on plateau.</span>
<span class="sd">        decoder_epochs : int</span>
<span class="sd">            Integer number of times to iterate over the training data arrays in decoder pretraining. If unspecified, it</span>
<span class="sd">            will default to 1000.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Arbitrary keyword arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set callbacks.</span>
        <span class="n">cbs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">reduce_lr_plateau</span><span class="p">:</span>
            <span class="n">cbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">ReduceLROnPlateau</span><span class="p">(</span>
                    <span class="n">monitor</span><span class="o">=</span><span class="n">monitor_partition</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">monitor_metric</span><span class="p">,</span>
                    <span class="n">factor</span><span class="o">=</span><span class="n">lr_schedule_factor</span><span class="p">,</span>
                    <span class="n">patience</span><span class="o">=</span><span class="n">lr_schedule_patience</span><span class="p">,</span>
                    <span class="n">min_lr</span><span class="o">=</span><span class="n">lr_schedule_min_lr</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">early_stopping</span><span class="p">:</span>
            <span class="n">cbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">EarlyStopping</span><span class="p">(</span>
                    <span class="n">monitor</span><span class="o">=</span><span class="n">monitor_partition</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">monitor_metric</span><span class="p">,</span> <span class="n">patience</span><span class="o">=</span><span class="n">patience</span><span class="p">,</span> <span class="n">restore_best_weights</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">log_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">TensorBoard</span><span class="p">(</span>
                    <span class="n">log_dir</span><span class="o">=</span><span class="n">log_dir</span><span class="p">,</span>
                    <span class="n">histogram_freq</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">write_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">write_grads</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">write_images</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">embeddings_freq</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">embeddings_layer_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">embeddings_metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">embeddings_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">update_freq</span><span class="o">=</span><span class="s2">&quot;epoch&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">callbacks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># callbacks needs to be a list</span>
            <span class="n">cbs</span> <span class="o">+=</span> <span class="n">callbacks</span>

        <span class="n">history</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">decoder_sampling</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">train_dataset</span><span class="p">,</span>
            <span class="n">epochs</span><span class="o">=</span><span class="n">decoder_epochs</span><span class="p">,</span>
            <span class="n">initial_epoch</span><span class="o">=</span><span class="n">initial_epoch</span><span class="p">,</span>
            <span class="n">steps_per_epoch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">steps_per_epoch</span><span class="p">,</span>
            <span class="n">callbacks</span><span class="o">=</span><span class="n">cbs</span><span class="p">,</span>
            <span class="n">validation_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eval_dataset</span><span class="p">,</span>
            <span class="n">validation_steps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">validation_steps</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">history</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">history</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  <span class="c1"># append to history if train() has been called before.</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="c1"># Transfer weights:</span>
        <span class="n">layer_names_training_model</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">training_model</span><span class="o">.</span><span class="n">layers</span><span class="p">]</span>
        <span class="n">layer_names_decoder_model</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">decoder_sampling</span><span class="o">.</span><span class="n">layers</span><span class="p">]</span>
        <span class="n">layers_updated</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">layer_names_decoder_model</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">decoder_sampling</span><span class="o">.</span><span class="n">get_layer</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">get_weights</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">layer_names_training_model</span><span class="p">:</span>
                <span class="c1"># Only update layers with parameters:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">training_model</span><span class="o">.</span><span class="n">get_layer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                    <span class="n">layers_updated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s2">&quot;Output_sampling&quot;</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="c1"># Find output layer *Output_decoder matched to *Output_sampling:</span>
                <span class="n">x_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">layer_names_training_model</span> <span class="k">if</span> <span class="s2">&quot;Output_decoder&quot;</span> <span class="ow">in</span> <span class="n">y</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">training_model</span><span class="o">.</span><span class="n">get_layer</span><span class="p">(</span><span class="n">x_out</span><span class="p">)</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="n">layers_updated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_out</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;updated layers: </span><span class="si">{</span><span class="n">layers_updated</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Estimator.train_aggressive"><a class="viewcode-back" href="../../../api/ncem.estimators.Estimator.train_aggressive.html#ncem.estimators.Estimator.train_aggressive">[docs]</a>    <span class="k">def</span> <span class="nf">train_aggressive</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">aggressive_enc_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">aggressive_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Train model aggressive.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        aggressive_enc_patience : int</span>
<span class="sd">             Number of epochs with no improvement in aggressive training. If unspecified, it will default to 10.</span>
<span class="sd">        aggressive_epochs : int</span>
<span class="sd">            Integer number of times to iterate over the training data arrays in aggressive training. If unspecified, it</span>
<span class="sd">            will default to 5.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># @tf.function</span>
        <span class="k">def</span> <span class="nf">train_iter</span><span class="p">(</span>
            <span class="n">x_batch_aggressive</span><span class="p">,</span>
            <span class="n">y_batch_aggressive</span><span class="p">,</span>
            <span class="n">train_dec</span><span class="p">,</span>
            <span class="n">train_enc</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">with</span> <span class="n">tf</span><span class="o">.</span><span class="n">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">g</span><span class="p">:</span>
                <span class="n">output_decoder_concat</span><span class="p">,</span> <span class="n">latent_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">training_model</span><span class="p">(</span><span class="n">x_batch_aggressive</span><span class="p">)</span>
                <span class="n">losses_aggressive</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;reconstruction_loss&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">y_batch_aggressive</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">output_decoder_concat</span><span class="p">),</span>
                    <span class="s2">&quot;bottleneck_loss&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="n">y_batch_aggressive</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">latent_space</span><span class="p">),</span>
                <span class="p">}</span>
                <span class="n">losses_aggressive</span><span class="p">[</span><span class="s2">&quot;loss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">losses_aggressive</span><span class="p">[</span><span class="s2">&quot;reconstruction_loss&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">losses_aggressive</span><span class="p">[</span><span class="s2">&quot;bottleneck_loss&quot;</span><span class="p">]</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">train_enc</span><span class="p">:</span>
                <span class="n">grad_enc</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span>
                    <span class="n">target</span><span class="o">=</span><span class="n">losses_aggressive</span><span class="p">[</span><span class="s2">&quot;loss&quot;</span><span class="p">],</span> <span class="n">sources</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">encoder_model</span><span class="o">.</span><span class="n">trainable_variables</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">apply_gradients</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">grad_enc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">encoder_model</span><span class="o">.</span><span class="n">trainable_variables</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">train_dec</span><span class="p">:</span>
                <span class="n">grad_dec</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span>
                    <span class="n">target</span><span class="o">=</span><span class="n">losses_aggressive</span><span class="p">[</span><span class="s2">&quot;loss&quot;</span><span class="p">],</span> <span class="n">sources</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">decoder_model</span><span class="o">.</span><span class="n">trainable_variables</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">apply_gradients</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">grad_dec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">decoder_model</span><span class="o">.</span><span class="n">trainable_variables</span><span class="p">))</span>

            <span class="n">metrics_values_output</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;reconstruction_&quot;</span> <span class="o">+</span> <span class="n">metric</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">metric</span><span class="p">(</span><span class="n">y_batch_aggressive</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">output_decoder_concat</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">}</span>
            <span class="n">metrics_values_latent</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;bottleneck_&quot;</span> <span class="o">+</span> <span class="n">metric</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">metric</span><span class="p">(</span><span class="n">y_batch_aggressive</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">latent_space</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">}</span>
            <span class="n">losses_aggressive</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">metrics_values_output</span><span class="p">)</span>
            <span class="n">losses_aggressive</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">metrics_values_latent</span><span class="p">)</span>

            <span class="c1"># Add non-scaled ELBO to model as metric (ie no annealing or beta-VAE scaling):</span>
            <span class="n">log2pi</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
            <span class="n">z</span><span class="p">,</span> <span class="n">z_mean</span><span class="p">,</span> <span class="n">z_log_var</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">latent_space</span><span class="p">,</span> <span class="n">num_or_size_splits</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">logqz_x</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="n">z_mean</span><span class="p">)</span> <span class="o">*</span> <span class="n">tf</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">z_log_var</span><span class="p">)</span> <span class="o">+</span> <span class="n">z_log_var</span> <span class="o">+</span> <span class="n">log2pi</span><span class="p">)</span>
            <span class="n">logpz</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">log2pi</span><span class="p">)</span>
            <span class="n">d_kl</span> <span class="o">=</span> <span class="n">logqz_x</span> <span class="o">-</span> <span class="n">logpz</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">output_decoder_concat</span><span class="p">,</span> <span class="n">num_or_size_splits</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">input_x</span> <span class="o">=</span> <span class="n">x_batch_aggressive</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_layer</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_layer</span> <span class="o">==</span> <span class="s2">&quot;gaussian_const_disp&quot;</span><span class="p">:</span>
                <span class="n">neg_ll</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">square</span><span class="p">(</span>
                    <span class="n">loc</span> <span class="o">-</span> <span class="n">input_x</span>
                <span class="p">)</span> <span class="o">/</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output_layer</span> <span class="o">==</span> <span class="s2">&quot;nb&quot;</span>
                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_layer</span> <span class="o">==</span> <span class="s2">&quot;nb_const_disp&quot;</span>
                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_layer</span> <span class="o">==</span> <span class="s2">&quot;nb_shared_disp&quot;</span>
            <span class="p">):</span>
                <span class="n">eta_loc</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
                <span class="n">eta_scale</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>

                <span class="n">log_r_plus_mu</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">scale</span> <span class="o">+</span> <span class="n">loc</span><span class="p">)</span>

                <span class="n">ll</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">lgamma</span><span class="p">(</span><span class="n">scale</span> <span class="o">+</span> <span class="n">input_x</span><span class="p">)</span>
                <span class="n">ll</span> <span class="o">=</span> <span class="n">ll</span> <span class="o">-</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">lgamma</span><span class="p">(</span><span class="n">input_x</span> <span class="o">+</span> <span class="n">tf</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">input_x</span><span class="p">))</span>
                <span class="n">ll</span> <span class="o">=</span> <span class="n">ll</span> <span class="o">-</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">lgamma</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
                <span class="n">ll</span> <span class="o">=</span> <span class="n">ll</span> <span class="o">+</span> <span class="n">tf</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">input_x</span><span class="p">,</span> <span class="n">eta_loc</span> <span class="o">-</span> <span class="n">log_r_plus_mu</span><span class="p">)</span> <span class="o">+</span> <span class="n">tf</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">eta_scale</span> <span class="o">-</span> <span class="n">log_r_plus_mu</span><span class="p">)</span>

                <span class="n">neg_ll</span> <span class="o">=</span> <span class="o">-</span><span class="n">tf</span><span class="o">.</span><span class="n">clip_by_value</span><span class="p">(</span><span class="n">ll</span><span class="p">,</span> <span class="o">-</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="s2">&quot;log_probs&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">neg_ll</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">neg_ll</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">neg_ll</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">losses_aggressive</span><span class="p">[</span><span class="s2">&quot;elbo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">neg_ll</span> <span class="o">+</span> <span class="n">d_kl</span>

            <span class="k">return</span> <span class="n">losses_aggressive</span>

        <span class="n">aggressive</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">history</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ep</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">aggressive</span><span class="p">:</span>
            <span class="n">ep</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Epoch (aggressive) </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2"> - &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">aggressive_epochs</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">no_improvement</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">best_result</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># inner loop training only encoder until no further improvement in ELBO val loss</span>
            <span class="n">enc_updates</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">no_improvement</span> <span class="o">&lt;</span> <span class="n">aggressive_enc_patience</span><span class="p">:</span>
                <span class="n">enc_updates</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">step</span><span class="p">,</span> <span class="p">(</span><span class="n">x_batch</span><span class="p">,</span> <span class="n">y_batch</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train_dataset</span><span class="p">):</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="n">step</span>
                    <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">steps_per_epoch</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">_</span> <span class="o">=</span> <span class="n">train_iter</span><span class="p">(</span>
                        <span class="n">x_batch_aggressive</span><span class="o">=</span><span class="n">x_batch</span><span class="p">,</span>
                        <span class="n">y_batch_aggressive</span><span class="o">=</span><span class="n">y_batch</span><span class="p">,</span>
                        <span class="n">train_enc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">train_dec</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="n">elbo_enc_epoch_eval</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">step</span><span class="p">,</span> <span class="p">(</span><span class="n">x_batch</span><span class="p">,</span> <span class="n">y_batch</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eval_dataset</span><span class="p">):</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="n">step</span>
                    <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">validation_steps</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">losses</span> <span class="o">=</span> <span class="n">train_iter</span><span class="p">(</span>
                        <span class="n">x_batch_aggressive</span><span class="o">=</span><span class="n">x_batch</span><span class="p">,</span>
                        <span class="n">y_batch_aggressive</span><span class="o">=</span><span class="n">y_batch</span><span class="p">,</span>
                        <span class="n">train_enc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">train_dec</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">elbo_enc_epoch_eval</span> <span class="o">+=</span> <span class="n">losses</span><span class="p">[</span><span class="s2">&quot;elbo&quot;</span><span class="p">]</span>
                <span class="n">elbo_enc_epoch_eval</span> <span class="o">/=</span> <span class="n">count</span>

                <span class="k">if</span> <span class="n">best_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">best_result</span> <span class="o">=</span> <span class="n">elbo_enc_epoch_eval</span>
                <span class="k">elif</span> <span class="n">elbo_enc_epoch_eval</span> <span class="o">&lt;</span> <span class="n">best_result</span><span class="p">:</span>
                    <span class="n">best_result</span> <span class="o">=</span> <span class="n">elbo_enc_epoch_eval</span>
                    <span class="n">no_improvement</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">no_improvement</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Performed </span><span class="si">%d</span><span class="s2"> encoder updates&quot;</span> <span class="o">%</span> <span class="n">enc_updates</span><span class="p">)</span>

            <span class="c1"># one step decoder training</span>
            <span class="n">hist</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">step</span><span class="p">,</span> <span class="p">(</span><span class="n">x_batch</span><span class="p">,</span> <span class="n">y_batch</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train_dataset</span><span class="p">):</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">step</span>
                <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">steps_per_epoch</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">losses</span> <span class="o">=</span> <span class="n">train_iter</span><span class="p">(</span>
                    <span class="n">x_batch_aggressive</span><span class="o">=</span><span class="n">x_batch</span><span class="p">,</span>
                    <span class="n">y_batch_aggressive</span><span class="o">=</span><span class="n">y_batch</span><span class="p">,</span>
                    <span class="n">train_enc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">train_dec</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">losses</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">hist</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">hist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">hist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">hist</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="o">/</span> <span class="n">count</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">hist</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">hist</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">history</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">history</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">history</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="n">hist_eval</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">step</span><span class="p">,</span> <span class="p">(</span><span class="n">x_batch</span><span class="p">,</span> <span class="n">y_batch</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eval_dataset</span><span class="p">):</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">step</span>
                <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">validation_steps</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">losses</span> <span class="o">=</span> <span class="n">train_iter</span><span class="p">(</span>
                    <span class="n">x_batch_aggressive</span><span class="o">=</span><span class="n">x_batch</span><span class="p">,</span>
                    <span class="n">y_batch_aggressive</span><span class="o">=</span><span class="n">y_batch</span><span class="p">,</span>
                    <span class="n">train_enc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">train_dec</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">losses</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">hist_eval</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">hist_eval</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">hist_eval</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">hist_eval</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;val_&quot;</span> <span class="o">+</span> <span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="o">/</span> <span class="n">count</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">hist_eval</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">hist_eval</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">history</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">history</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">history</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;lr&quot;</span> <span class="ow">in</span> <span class="n">history</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">history</span><span class="p">[</span><span class="s2">&quot;lr&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">lr</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">history</span><span class="p">[</span><span class="s2">&quot;lr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">lr</span><span class="o">.</span><span class="n">numpy</span><span class="p">()]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">history</span><span class="p">[</span><span class="s2">&quot;loss&quot;</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">aggressive_epochs</span><span class="p">:</span>
                <span class="n">aggressive</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">/</span><span class="si">%d</span><span class="s2"> - </span><span class="si">%d</span><span class="s2">s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">steps_per_epoch</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steps_per_epoch</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">loss</span> <span class="ow">in</span> <span class="n">history</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - </span><span class="si">%s</span><span class="s2">: </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">loss</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">history</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  <span class="c1"># append to history if train() has been called before.</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span></div>

    <span class="k">def</span> <span class="nf">_get_dataset_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get test dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        batch_size : int</span>
<span class="sd">            Number of samples. If unspecified, it will default to 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A tensorflow dataset.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_keys_test</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_keys_test</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">image_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_keys_test</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Image keys for test set empty. Evaluating on all images in whole dataset!&quot;</span><span class="p">)</span>
            <span class="n">image_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">complete_img_keys</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_test</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nodes_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_idx_test</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Node idx for test set empty. Evaluating on all nodes in whole dataset!&quot;</span><span class="p">)</span>
            <span class="n">nodes_idx</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dataset</span><span class="p">(</span>
            <span class="n">image_keys</span><span class="o">=</span><span class="n">image_keys</span><span class="p">,</span>
            <span class="n">nodes_idx</span><span class="o">=</span><span class="n">nodes_idx</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">shuffle_buffer_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">train</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">reinit_n_eval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Estimator.predict"><a class="viewcode-back" href="../../../api/ncem.estimators.Estimator.predict.html#ncem.estimators.Estimator.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return observed labels and full predictions (including scale model) grouped exactly as in nodes_idx_test.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        batch_size : int</span>
<span class="sd">            Number of samples. If unspecified, it will default to 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dataset_test</span><span class="p">(</span><span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">training_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span></div>

<div class="viewcode-block" id="Estimator.evaluate_any"><a class="viewcode-back" href="../../../api/ncem.estimators.Estimator.evaluate_any.html#ncem.estimators.Estimator.evaluate_any">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_any</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img_keys</span><span class="p">,</span> <span class="n">node_idx</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate model on any given data set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        img_keys</span>
<span class="sd">            Image keys.</span>
<span class="sd">        node_idx</span>
<span class="sd">            Nodes indices.</span>
<span class="sd">        batch_size : int</span>
<span class="sd">            Number of samples. If unspecified, it will default to 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        eval_dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dataset</span><span class="p">(</span>
            <span class="n">image_keys</span><span class="o">=</span><span class="n">img_keys</span><span class="p">,</span>
            <span class="n">nodes_idx</span><span class="o">=</span><span class="n">node_idx</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">shuffle_buffer_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">train</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">reinit_n_eval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">training_model</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">eval_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">training_model</span><span class="o">.</span><span class="n">metrics_names</span><span class="p">,</span> <span class="n">results</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">eval_dict</span></div>

<div class="viewcode-block" id="Estimator.evaluate_per_node_type"><a class="viewcode-back" href="../../../api/ncem.estimators.Estimator.evaluate_per_node_type.html#ncem.estimators.Estimator.evaluate_per_node_type">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_per_node_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate model for each node type seperately.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        batch_size : int</span>
<span class="sd">            Number of samples. If unspecified, it will default to 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        split_per_node_type, evaluation_per_node_type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulation</span><span class="p">:</span>
            <span class="n">split_per_node_type</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">evaluation_per_node_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">evaluation_per_node_type</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">split_per_node_type</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">node_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_type_names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">nt</span> <span class="ow">in</span> <span class="n">node_types</span><span class="p">:</span>
                <span class="n">img_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">complete_img_keys</span><span class="p">)</span>
                <span class="n">nodes_idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_types</span><span class="p">[</span><span class="n">k</span><span class="p">][:,</span> <span class="n">node_types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">nt</span><span class="p">)]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">img_keys</span><span class="p">}</span>
                <span class="n">split_per_node_type</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">nt</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;img_keys&quot;</span><span class="p">:</span> <span class="n">img_keys</span><span class="p">,</span> <span class="s2">&quot;nodes_idx&quot;</span><span class="p">:</span> <span class="n">nodes_idx</span><span class="p">}})</span>
                <span class="n">test</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_types</span><span class="p">[</span><span class="n">k</span><span class="p">][:,</span> <span class="n">node_types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">nt</span><span class="p">)]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">img_keys</span><span class="p">}</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Evaluation for </span><span class="si">%s</span><span class="s2"> with </span><span class="si">%i</span><span class="s2"> cells&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>
                <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dataset</span><span class="p">(</span>
                    <span class="n">image_keys</span><span class="o">=</span><span class="n">img_keys</span><span class="p">,</span>
                    <span class="n">nodes_idx</span><span class="o">=</span><span class="n">nodes_idx</span><span class="p">,</span>
                    <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
                    <span class="n">shuffle_buffer_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">train</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">reinit_n_eval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">training_model</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">eval_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">training_model</span><span class="o">.</span><span class="n">metrics_names</span><span class="p">,</span> <span class="n">results</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">eval_dict</span><span class="p">)</span>
                <span class="n">evaluation_per_node_type</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">nt</span><span class="p">:</span> <span class="n">eval_dict</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">split_per_node_type</span><span class="p">,</span> <span class="n">evaluation_per_node_type</span></div></div>


<div class="viewcode-block" id="EstimatorGraph"><a class="viewcode-back" href="../../../api/ncem.estimators.EstimatorGraph.html#ncem.estimators.EstimatorGraph">[docs]</a><span class="k">class</span> <span class="nc">EstimatorGraph</span><span class="p">(</span><span class="n">Estimator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;EstimatorGraph class for spatial models.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="EstimatorGraph.init_model"><a class="viewcode-back" href="../../../api/ncem.estimators.EstimatorGraph.init_model.html#ncem.estimators.EstimatorGraph.init_model">[docs]</a>    <span class="k">def</span> <span class="nf">init_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize EstimatorGraph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs</span>
<span class="sd">            Arbitrary keyword arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="k">def</span> <span class="nf">_get_output_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resampled</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get output signatures.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        resampled : bool</span>
<span class="sd">            Whether dataset is resampled or not.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output_signature</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h_1</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_features_1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>  <span class="c1"># input node features</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>  <span class="c1"># input node size factors</span>
        <span class="n">h_0</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_features_0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>  <span class="c1"># input node features conditional</span>
        <span class="n">h_0_full</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_features_0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>  <span class="c1"># input node features conditional</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SparseTensorSpec</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>  <span class="c1"># adjacency matrix</span>
        <span class="n">a_full</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SparseTensorSpec</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>  <span class="c1"># adjacency matrix</span>
        <span class="n">node_covar</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_node_covariates</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>  <span class="c1"># node-level covariates</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_domains</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>  <span class="c1"># domain</span>
        <span class="n">reconstruction</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_features_1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>  <span class="c1"># node features to reconstruct</span>
        <span class="n">kl_dummy</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>  <span class="c1"># dummy for kl loss</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi_model</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">resampled</span><span class="p">:</span>
                <span class="n">output_signature</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">h_1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">h_0</span><span class="p">,</span> <span class="n">h_0_full</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a_full</span><span class="p">,</span> <span class="n">node_covar</span><span class="p">,</span> <span class="n">domain</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">reconstruction</span><span class="p">,</span> <span class="n">kl_dummy</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">h_1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">h_0</span><span class="p">,</span> <span class="n">h_0_full</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a_full</span><span class="p">,</span> <span class="n">node_covar</span><span class="p">,</span> <span class="n">domain</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">reconstruction</span><span class="p">,</span> <span class="n">kl_dummy</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output_signature</span> <span class="o">=</span> <span class="p">((</span><span class="n">h_1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">h_0</span><span class="p">,</span> <span class="n">h_0_full</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a_full</span><span class="p">,</span> <span class="n">node_covar</span><span class="p">,</span> <span class="n">domain</span><span class="p">),</span> <span class="p">(</span><span class="n">reconstruction</span><span class="p">,</span> <span class="n">kl_dummy</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">resampled</span><span class="p">:</span>
                <span class="n">output_signature</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">h_1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">h_0</span><span class="p">,</span> <span class="n">h_0_full</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a_full</span><span class="p">,</span> <span class="n">node_covar</span><span class="p">,</span> <span class="n">domain</span><span class="p">),</span>
                    <span class="n">reconstruction</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">h_1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">h_0</span><span class="p">,</span> <span class="n">h_0_full</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a_full</span><span class="p">,</span> <span class="n">node_covar</span><span class="p">,</span> <span class="n">domain</span><span class="p">),</span>
                    <span class="n">reconstruction</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output_signature</span> <span class="o">=</span> <span class="p">((</span><span class="n">h_1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">h_0</span><span class="p">,</span> <span class="n">h_0_full</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a_full</span><span class="p">,</span> <span class="n">node_covar</span><span class="p">,</span> <span class="n">domain</span><span class="p">),</span> <span class="n">reconstruction</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output_signature</span>

    <span class="k">def</span> <span class="nf">_get_dataset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">image_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">nodes_idx</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">shuffle_buffer_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">train</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">prefetch</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">reinit_n_eval</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prepare a dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        image_keys : np.array</span>
<span class="sd">            Image keys in partition.</span>
<span class="sd">        nodes_idx : dict, str</span>
<span class="sd">            Dictionary of nodes per image in partition.</span>
<span class="sd">        batch_size : int</span>
<span class="sd">            Batch size.</span>
<span class="sd">        shuffle_buffer_size : int, optional</span>
<span class="sd">            Shuffle buffer size.</span>
<span class="sd">        train : bool</span>
<span class="sd">            Whether dataset is used for training or not (influences shuffling of nodes).</span>
<span class="sd">        seed : int, optional</span>
<span class="sd">            Random seed.</span>
<span class="sd">        prefetch: int</span>
<span class="sd">            Prefetch of dataset.</span>
<span class="sd">        reinit_n_eval : int, optional</span>
<span class="sd">            Used if model is reinitialized to different number of nodes per graph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A tensorflow dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reinit_n_eval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">reinit_n_eval</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;ATTENTION: specifying reinit_n_eval will change class argument n_eval_nodes_per_graph &quot;</span>
                <span class="s2">&quot;from </span><span class="si">%i</span><span class="s2"> to </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,</span> <span class="n">reinit_n_eval</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span> <span class="o">=</span> <span class="n">reinit_n_eval</span>

        <span class="k">def</span> <span class="nf">generator</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">image_keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nodes_idx</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># needed for images where no nodes are selected</span>
                    <span class="k">continue</span>
                <span class="n">idx_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">train</span><span class="p">:</span>
                    <span class="n">index_list</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                                <span class="n">a</span><span class="o">=</span><span class="n">nodes_idx</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                                <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,</span>
                                <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="p">),</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># dropping</span>
                    <span class="n">index_list</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                            <span class="n">nodes_idx</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span> <span class="o">*</span> <span class="n">i</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes_idx</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">)</span>
                    <span class="p">]</span>

                <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">index_list</span><span class="p">:</span>
                    <span class="n">h_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_0</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx_nodes</span><span class="p">]</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span> <span class="o">-</span> <span class="n">h_0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">h_0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">h_0_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">h_0</span><span class="p">,</span> <span class="n">zeros</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">h_0</span> <span class="o">=</span> <span class="n">h_0_full</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>

                    <span class="n">h_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_1</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx_nodes</span><span class="p">]</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span> <span class="o">-</span> <span class="n">h_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">h_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">h_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">h_1</span><span class="p">,</span> <span class="n">zeros</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">h_1</span> <span class="o">=</span> <span class="n">h_1</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_transform</span><span class="p">:</span>
                        <span class="n">h_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">h_1</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>

                    <span class="c1"># indexing adjacency matrix that yield only selected cells (final graph layer)</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx_nodes</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">idx_nodes</span><span class="p">]</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">coo</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>
                    <span class="n">a_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">([</span><span class="n">coo</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">coo</span><span class="o">.</span><span class="n">col</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
                    <span class="n">a_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">coo</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">a_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SparseTensor</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">a_ind</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">a_val</span><span class="p">,</span> <span class="n">dense_shape</span><span class="o">=</span><span class="n">a_shape</span><span class="p">)</span>
                    <span class="c1"># propagating adjacency matrix that yield all cells (before final graph layer)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cond_depth</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">a_full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx_nodes</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">idx_nodes</span><span class="p">]</span>
                        <span class="n">a_full</span> <span class="o">=</span> <span class="n">a_full</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>
                        <span class="n">afull_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">([</span><span class="n">a_full</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">a_full</span><span class="o">.</span><span class="n">col</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
                        <span class="n">afull_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a_full</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">afull_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,)),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,))])</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
                        <span class="n">afull_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,)),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">afull_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
                    <span class="n">a_full</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SparseTensor</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">afull_ind</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">afull_val</span><span class="p">,</span> <span class="n">dense_shape</span><span class="o">=</span><span class="n">afull_shape</span><span class="p">)</span>

                    <span class="n">node_covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_covar</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx_nodes</span><span class="p">]</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span> <span class="o">-</span> <span class="n">node_covar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">node_covar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="n">node_covar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">node_covar</span><span class="p">,</span> <span class="n">zeros</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">node_covar</span> <span class="o">=</span> <span class="n">node_covar</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="p">:]</span>

                    <span class="n">sf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size_factors</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx_nodes</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span> <span class="o">-</span> <span class="n">sf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">sf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="n">sf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">sf</span><span class="p">,</span> <span class="n">zeros</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">sf</span> <span class="o">=</span> <span class="n">sf</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="p">:]</span>

                    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_domains</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
                    <span class="n">g</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">domains</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi_model</span><span class="p">:</span>
                        <span class="n">kl_dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                        <span class="k">yield</span> <span class="p">(</span><span class="n">h_1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">h_0</span><span class="p">,</span> <span class="n">h_0_full</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a_full</span><span class="p">,</span> <span class="n">node_covar</span><span class="p">,</span> <span class="n">g</span><span class="p">),</span> <span class="p">(</span><span class="n">h_1</span><span class="p">,</span> <span class="n">kl_dummy</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="p">(</span><span class="n">h_1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">h_0</span><span class="p">,</span> <span class="n">h_0_full</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a_full</span><span class="p">,</span> <span class="n">node_covar</span><span class="p">,</span> <span class="n">g</span><span class="p">),</span> <span class="n">h_1</span>

        <span class="n">output_signature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_output_signature</span><span class="p">(</span><span class="n">resampled</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">dataset</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">from_generator</span><span class="p">(</span><span class="n">generator</span><span class="o">=</span><span class="n">generator</span><span class="p">,</span> <span class="n">output_signature</span><span class="o">=</span><span class="n">output_signature</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">train</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">shuffle_buffer_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">buffer_size</span><span class="o">=</span><span class="n">shuffle_buffer_size</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reshuffle_each_iteration</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">repeat</span><span class="p">()</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">prefetch</span><span class="p">(</span><span class="n">prefetch</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dataset</span>

    <span class="k">def</span> <span class="nf">_get_resampled_dataset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">image_keys</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">nodes_idx</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">prefetch</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">reinit_n_eval</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate model based on resampled dataset for posterior resampling.</span>

<span class="sd">        node_1 + domain_1 -&gt; encoder -&gt; z_1 + domain_2 -&gt; decoder -&gt; reconstruction_2.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        image_keys: np.array</span>
<span class="sd">            Image keys in partition.</span>
<span class="sd">        nodes_idx : dict</span>
<span class="sd">            Dictionary of nodes per image in partition.</span>
<span class="sd">        batch_size : int</span>
<span class="sd">            Batch size.</span>
<span class="sd">        seed : int, optional</span>
<span class="sd">            Seed.</span>
<span class="sd">        prefetch : int</span>
<span class="sd">            Prefetch.</span>
<span class="sd">        reinit_n_eval : int, optional</span>
<span class="sd">            Used if model is reinitialized to different number of nodes per graph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A tensorflow dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reinit_n_eval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;ATTENTION: specifying reinit_n_eval will change class argument n_eval_nodes_per_graph &quot;</span>
                <span class="s2">&quot;from </span><span class="si">%i</span><span class="s2"> to </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,</span> <span class="n">reinit_n_eval</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span> <span class="o">=</span> <span class="n">reinit_n_eval</span>

        <span class="k">def</span> <span class="nf">generator</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">image_keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nodes_idx</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># needed for images where no nodes are selected</span>
                    <span class="k">continue</span>
                <span class="n">idx_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="n">index_list</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                        <span class="n">nodes_idx</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span> <span class="o">*</span> <span class="n">i</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes_idx</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="n">resampled_index_list</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                            <span class="n">a</span><span class="o">=</span><span class="n">nodes_idx</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                            <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,</span>
                            <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="p">),</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes_idx</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">)</span>
                <span class="p">]</span>

                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">index_list</span><span class="p">):</span>
                    <span class="n">re_indices</span> <span class="o">=</span> <span class="n">resampled_index_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                    <span class="n">h_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_0</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx_nodes</span><span class="p">]</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span> <span class="o">-</span> <span class="n">h_0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">h_0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">h_0_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">h_0</span><span class="p">,</span> <span class="n">zeros</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">re_h_0</span> <span class="o">=</span> <span class="n">h_0_full</span><span class="p">[</span><span class="n">re_indices</span><span class="p">]</span>
                    <span class="n">h_0</span> <span class="o">=</span> <span class="n">h_0_full</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>

                    <span class="n">h_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_1</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx_nodes</span><span class="p">]</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span> <span class="o">-</span> <span class="n">h_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">h_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">h_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">h_1</span><span class="p">,</span> <span class="n">zeros</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">re_h_1</span> <span class="o">=</span> <span class="n">h_1</span><span class="p">[</span><span class="n">re_indices</span><span class="p">]</span>
                    <span class="n">h_1</span> <span class="o">=</span> <span class="n">h_1</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_transform</span><span class="p">:</span>
                        <span class="n">h_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">h_1</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
                        <span class="n">re_h_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">re_h_1</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>

                    <span class="c1"># indexing adjacency matrix that yield only selected cells (final graph layer)</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx_nodes</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">idx_nodes</span><span class="p">]</span>
                    <span class="n">re_a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">re_indices</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">re_coo</span> <span class="o">=</span> <span class="n">re_a</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>
                    <span class="n">re_a_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">([</span><span class="n">re_coo</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">re_coo</span><span class="o">.</span><span class="n">col</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
                    <span class="n">re_a_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">re_coo</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">re_a_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
                    <span class="n">re_a</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SparseTensor</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">re_a_ind</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">re_a_val</span><span class="p">,</span> <span class="n">dense_shape</span><span class="o">=</span><span class="n">re_a_shape</span><span class="p">)</span>

                    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">coo</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>
                    <span class="n">a_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">([</span><span class="n">coo</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">coo</span><span class="o">.</span><span class="n">col</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
                    <span class="n">a_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">coo</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">a_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SparseTensor</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">a_ind</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">a_val</span><span class="p">,</span> <span class="n">dense_shape</span><span class="o">=</span><span class="n">a_shape</span><span class="p">)</span>

                    <span class="c1"># propagating adjacency matrix that yield all cells (before final graph layer)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="s2">&quot;cond_depth&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">a_full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx_nodes</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">idx_nodes</span><span class="p">]</span>
                        <span class="n">a_full</span> <span class="o">=</span> <span class="n">a_full</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>
                        <span class="n">afull_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">([</span><span class="n">a_full</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">a_full</span><span class="o">.</span><span class="n">col</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
                        <span class="n">afull_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a_full</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">afull_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,)),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,))])</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
                        <span class="n">afull_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,)),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">afull_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
                    <span class="n">a_full</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SparseTensor</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">afull_ind</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">afull_val</span><span class="p">,</span> <span class="n">dense_shape</span><span class="o">=</span><span class="n">afull_shape</span><span class="p">)</span>

                    <span class="n">node_covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_covar</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx_nodes</span><span class="p">]</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span> <span class="o">-</span> <span class="n">node_covar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">node_covar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="n">node_covar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">node_covar</span><span class="p">,</span> <span class="n">zeros</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">re_node_covar</span> <span class="o">=</span> <span class="n">node_covar</span><span class="p">[</span><span class="n">re_indices</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">node_covar</span> <span class="o">=</span> <span class="n">node_covar</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="p">:]</span>

                    <span class="n">sf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size_factors</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx_nodes</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span> <span class="o">-</span> <span class="n">sf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">sf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="n">sf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">sf</span><span class="p">,</span> <span class="n">zeros</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">re_sf</span> <span class="o">=</span> <span class="n">sf</span><span class="p">[</span><span class="n">re_indices</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">sf</span> <span class="o">=</span> <span class="n">sf</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="p">:]</span>

                    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_domains</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
                    <span class="n">g</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">domains</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi_model</span><span class="p">:</span>
                        <span class="n">kl_dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                        <span class="k">yield</span> <span class="p">(</span><span class="n">h_1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">h_0</span><span class="p">,</span> <span class="n">h_0_full</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a_full</span><span class="p">,</span> <span class="n">node_covar</span><span class="p">,</span> <span class="n">g</span><span class="p">),</span> <span class="p">(</span><span class="n">h_1</span><span class="p">,</span> <span class="n">kl_dummy</span><span class="p">),</span> <span class="p">(</span>
                            <span class="n">re_h_1</span><span class="p">,</span>
                            <span class="n">re_sf</span><span class="p">,</span>
                            <span class="n">re_h_0</span><span class="p">,</span>
                            <span class="n">h_0_full</span><span class="p">,</span>
                            <span class="n">re_a</span><span class="p">,</span>
                            <span class="n">a_full</span><span class="p">,</span>
                            <span class="n">re_node_covar</span><span class="p">,</span>
                            <span class="n">g</span><span class="p">,</span>
                        <span class="p">),</span> <span class="p">(</span><span class="n">re_h_1</span><span class="p">,</span> <span class="n">kl_dummy</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="p">(</span><span class="n">h_1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">h_0</span><span class="p">,</span> <span class="n">h_0_full</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a_full</span><span class="p">,</span> <span class="n">node_covar</span><span class="p">,</span> <span class="n">g</span><span class="p">),</span> <span class="n">h_1</span><span class="p">,</span> <span class="p">(</span>
                            <span class="n">re_h_1</span><span class="p">,</span>
                            <span class="n">re_sf</span><span class="p">,</span>
                            <span class="n">re_h_0</span><span class="p">,</span>
                            <span class="n">h_0_full</span><span class="p">,</span>
                            <span class="n">re_a</span><span class="p">,</span>
                            <span class="n">a_full</span><span class="p">,</span>
                            <span class="n">re_node_covar</span><span class="p">,</span>
                            <span class="n">g</span><span class="p">,</span>
                        <span class="p">),</span> <span class="n">re_h_1</span>

        <span class="n">output_signature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_output_signature</span><span class="p">(</span><span class="n">resampled</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">dataset</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">from_generator</span><span class="p">(</span><span class="n">generator</span><span class="o">=</span><span class="n">generator</span><span class="p">,</span> <span class="n">output_signature</span><span class="o">=</span><span class="n">output_signature</span><span class="p">)</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">prefetch</span><span class="p">(</span><span class="n">prefetch</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dataset</span></div>


<div class="viewcode-block" id="EstimatorNoGraph"><a class="viewcode-back" href="../../../api/ncem.estimators.EstimatorNoGraph.html#ncem.estimators.EstimatorNoGraph">[docs]</a><span class="k">class</span> <span class="nc">EstimatorNoGraph</span><span class="p">(</span><span class="n">Estimator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;EstimatorNoGraph class for baseline models.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="EstimatorNoGraph.init_model"><a class="viewcode-back" href="../../../api/ncem.estimators.EstimatorNoGraph.init_model.html#ncem.estimators.EstimatorNoGraph.init_model">[docs]</a>    <span class="k">def</span> <span class="nf">init_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize EstimatorNoGraph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs</span>
<span class="sd">            Arbitrary keyword arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="k">def</span> <span class="nf">_get_output_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resampled</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get output signatures.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        resampled : bool</span>
<span class="sd">            Whether dataset is resampled or not.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output_signature</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h_1</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_features_1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>  <span class="c1"># input node features</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>  <span class="c1"># input node size factors</span>
        <span class="n">node_covar</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_node_covariates</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>  <span class="c1"># node-level covariates</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_domains</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>  <span class="c1"># domain</span>
        <span class="n">reconstruction</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_features_1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>  <span class="c1"># node features to reconstruct</span>
        <span class="n">kl_dummy</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>  <span class="c1"># dummy for kl loss</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi_model</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">resampled</span><span class="p">:</span>
                <span class="n">output_signature</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">h_1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">node_covar</span><span class="p">,</span> <span class="n">domain</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">reconstruction</span><span class="p">,</span> <span class="n">kl_dummy</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">h_1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">node_covar</span><span class="p">,</span> <span class="n">domain</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">reconstruction</span><span class="p">,</span> <span class="n">kl_dummy</span><span class="p">),</span>  <span class="c1"># shapes for resampled output</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output_signature</span> <span class="o">=</span> <span class="p">((</span><span class="n">h_1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">node_covar</span><span class="p">,</span> <span class="n">domain</span><span class="p">),</span> <span class="p">(</span><span class="n">reconstruction</span><span class="p">,</span> <span class="n">kl_dummy</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">resampled</span><span class="p">:</span>
                <span class="n">output_signature</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">h_1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">node_covar</span><span class="p">,</span> <span class="n">domain</span><span class="p">),</span>
                    <span class="n">reconstruction</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">h_1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">node_covar</span><span class="p">,</span> <span class="n">domain</span><span class="p">),</span>
                    <span class="n">reconstruction</span><span class="p">,</span>  <span class="c1"># shapes for resampled output</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output_signature</span> <span class="o">=</span> <span class="p">((</span><span class="n">h_1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">node_covar</span><span class="p">,</span> <span class="n">domain</span><span class="p">),</span> <span class="n">reconstruction</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output_signature</span>

    <span class="k">def</span> <span class="nf">_get_dataset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">image_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">nodes_idx</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">shuffle_buffer_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">train</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">prefetch</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">reinit_n_eval</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prepare a dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        image_keys : np.array</span>
<span class="sd">            Image keys in partition.</span>
<span class="sd">        nodes_idx : dict, str</span>
<span class="sd">            Dictionary of nodes per image in partition.</span>
<span class="sd">        batch_size : int</span>
<span class="sd">            Batch size.</span>
<span class="sd">        shuffle_buffer_size : int, optional</span>
<span class="sd">            Shuffle buffer size.</span>
<span class="sd">        train : bool</span>
<span class="sd">            Whether dataset is used for training or not (influences shuffling of nodes).</span>
<span class="sd">        seed : int, optional</span>
<span class="sd">            Random seed.</span>
<span class="sd">        prefetch: int</span>
<span class="sd">            Prefetch of dataset.</span>
<span class="sd">        reinit_n_eval : int, optional</span>
<span class="sd">            Used if model is reinitialized to different number of nodes per graph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A tensorflow dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reinit_n_eval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">reinit_n_eval</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;ATTENTION: specifying reinit_n_eval will change class argument n_eval_nodes_per_graph &quot;</span>
                <span class="s2">&quot;from </span><span class="si">%i</span><span class="s2"> to </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,</span> <span class="n">reinit_n_eval</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span> <span class="o">=</span> <span class="n">reinit_n_eval</span>

        <span class="k">def</span> <span class="nf">generator</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">image_keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nodes_idx</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># needed for images where no nodes are selected</span>
                    <span class="k">continue</span>
                <span class="n">idx_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">train</span><span class="p">:</span>
                    <span class="n">index_list</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                                <span class="n">a</span><span class="o">=</span><span class="n">nodes_idx</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                                <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,</span>
                                <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="p">),</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># dropping</span>
                    <span class="n">index_list</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                            <span class="n">nodes_idx</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span> <span class="o">*</span> <span class="n">i</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes_idx</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">)</span>
                    <span class="p">]</span>

                <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">index_list</span><span class="p">:</span>
                    <span class="n">h_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_1</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx_nodes</span><span class="p">]</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span> <span class="o">-</span> <span class="n">h_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">h_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="n">h_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">h_1</span><span class="p">,</span> <span class="n">zeros</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">h_1</span> <span class="o">=</span> <span class="n">h_1</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_transform</span><span class="p">:</span>
                        <span class="n">h_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">h_1</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>

                    <span class="n">node_covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_covar</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx_nodes</span><span class="p">]</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span> <span class="o">-</span> <span class="n">node_covar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">node_covar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="n">node_covar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">node_covar</span><span class="p">,</span> <span class="n">zeros</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">node_covar</span> <span class="o">=</span> <span class="n">node_covar</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>

                    <span class="n">sf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size_factors</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx_nodes</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span> <span class="o">-</span> <span class="n">sf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">sf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="n">sf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">sf</span><span class="p">,</span> <span class="n">zeros</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">sf</span> <span class="o">=</span> <span class="n">sf</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="p">:]</span>

                    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_domains</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
                    <span class="n">g</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">domains</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi_model</span><span class="p">:</span>
                        <span class="n">kl_dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                        <span class="k">yield</span> <span class="p">(</span><span class="n">h_1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">node_covar</span><span class="p">,</span> <span class="n">g</span><span class="p">),</span> <span class="p">(</span><span class="n">h_1</span><span class="p">,</span> <span class="n">kl_dummy</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="p">(</span><span class="n">h_1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">node_covar</span><span class="p">,</span> <span class="n">g</span><span class="p">),</span> <span class="n">h_1</span>

        <span class="n">output_signature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_output_signature</span><span class="p">(</span><span class="n">resampled</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">dataset</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">from_generator</span><span class="p">(</span><span class="n">generator</span><span class="o">=</span><span class="n">generator</span><span class="p">,</span> <span class="n">output_signature</span><span class="o">=</span><span class="n">output_signature</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">train</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">shuffle_buffer_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">buffer_size</span><span class="o">=</span><span class="n">shuffle_buffer_size</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reshuffle_each_iteration</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">repeat</span><span class="p">()</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">prefetch</span><span class="p">(</span><span class="n">prefetch</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dataset</span>

    <span class="k">def</span> <span class="nf">_get_resampled_dataset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">image_keys</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">nodes_idx</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">prefetch</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">reinit_n_eval</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate model based on resampled dataset for posterior resampling.</span>

<span class="sd">        node_1 + domain_1 -&gt; encoder -&gt; z_1 + domain_2 -&gt; decoder -&gt; reconstruction_2.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        image_keys: np.array</span>
<span class="sd">            Image keys in partition.</span>
<span class="sd">        nodes_idx : dict</span>
<span class="sd">            Dictionary of nodes per image in partition.</span>
<span class="sd">        batch_size : int</span>
<span class="sd">            Batch size.</span>
<span class="sd">        seed : int, optional</span>
<span class="sd">            Seed.</span>
<span class="sd">        prefetch : int</span>
<span class="sd">            Prefetch.</span>
<span class="sd">        reinit_n_eval : int, optional</span>
<span class="sd">            Used if model is reinitialized to different number of nodes per graph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A tensorflow dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reinit_n_eval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;ATTENTION: specifying reinit_n_eval will change class argument n_eval_nodes_per_graph &quot;</span>
                <span class="s2">&quot;from </span><span class="si">%i</span><span class="s2"> to </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,</span> <span class="n">reinit_n_eval</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span> <span class="o">=</span> <span class="n">reinit_n_eval</span>

        <span class="k">def</span> <span class="nf">generator</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">image_keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nodes_idx</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># needed for images where no nodes are selected</span>
                    <span class="k">continue</span>
                <span class="n">idx_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="n">index_list</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                        <span class="n">nodes_idx</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span> <span class="o">*</span> <span class="n">i</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes_idx</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="n">resampled_index_list</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                            <span class="n">a</span><span class="o">=</span><span class="n">nodes_idx</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                            <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,</span>
                            <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="p">),</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes_idx</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">)</span>
                <span class="p">]</span>

                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">index_list</span><span class="p">):</span>
                    <span class="n">re_indices</span> <span class="o">=</span> <span class="n">resampled_index_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                    <span class="n">h_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_1</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx_nodes</span><span class="p">]</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span> <span class="o">-</span> <span class="n">h_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">h_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="n">h_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">h_1</span><span class="p">,</span> <span class="n">zeros</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">re_h_1</span> <span class="o">=</span> <span class="n">h_1</span><span class="p">[</span><span class="n">re_indices</span><span class="p">]</span>
                    <span class="n">h_1</span> <span class="o">=</span> <span class="n">h_1</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_transform</span><span class="p">:</span>
                        <span class="n">h_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">h_1</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
                        <span class="n">re_h_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">re_h_1</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>

                    <span class="n">node_covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_covar</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx_nodes</span><span class="p">]</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span> <span class="o">-</span> <span class="n">node_covar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">node_covar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="n">node_covar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">node_covar</span><span class="p">,</span> <span class="n">zeros</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">re_node_covar</span> <span class="o">=</span> <span class="n">node_covar</span><span class="p">[</span><span class="n">re_indices</span><span class="p">]</span>
                    <span class="n">node_covar</span> <span class="o">=</span> <span class="n">node_covar</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>

                    <span class="n">sf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size_factors</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx_nodes</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span> <span class="o">-</span> <span class="n">sf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">sf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="n">sf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">sf</span><span class="p">,</span> <span class="n">zeros</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="n">re_sf</span> <span class="o">=</span> <span class="n">sf</span><span class="p">[</span><span class="n">re_indices</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">sf</span> <span class="o">=</span> <span class="n">sf</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="p">:]</span>

                    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_domains</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
                    <span class="n">g</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">domains</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi_model</span><span class="p">:</span>
                        <span class="n">kl_dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eval_nodes_per_graph</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                        <span class="k">yield</span> <span class="p">(</span><span class="n">h_1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">node_covar</span><span class="p">,</span> <span class="n">g</span><span class="p">),</span> <span class="p">(</span><span class="n">h_1</span><span class="p">,</span> <span class="n">kl_dummy</span><span class="p">),</span> <span class="p">(</span><span class="n">re_h_1</span><span class="p">,</span> <span class="n">re_sf</span><span class="p">,</span> <span class="n">re_node_covar</span><span class="p">,</span> <span class="n">g</span><span class="p">),</span> <span class="p">(</span>
                            <span class="n">re_h_1</span><span class="p">,</span>
                            <span class="n">kl_dummy</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="p">(</span><span class="n">h_1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">node_covar</span><span class="p">,</span> <span class="n">g</span><span class="p">),</span> <span class="n">h_1</span><span class="p">,</span> <span class="p">(</span><span class="n">re_h_1</span><span class="p">,</span> <span class="n">re_sf</span><span class="p">,</span> <span class="n">re_node_covar</span><span class="p">,</span> <span class="n">g</span><span class="p">),</span> <span class="n">re_h_1</span>

        <span class="n">output_signature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_output_signature</span><span class="p">(</span><span class="n">resampled</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">dataset</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">from_generator</span><span class="p">(</span><span class="n">generator</span><span class="o">=</span><span class="n">generator</span><span class="p">,</span> <span class="n">output_signature</span><span class="o">=</span><span class="n">output_signature</span><span class="p">)</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">prefetch</span><span class="p">(</span><span class="n">prefetch</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dataset</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, theislab.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>